\documentclass[10pt,twoside,a4paper]{report}

\usepackage{polski}
\usepackage{indentfirst}
\usepackage{sectsty}
\usepackage{helvet}
\usepackage{caption}
\usepackage{multirow}
\usepackage{makecell}
\usepackage{array}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage[section]{placeins}
\usepackage{enumitem}% http://ctan.org/pkg/enumitem
\setlist[itemize]{noitemsep, topsep=0pt}
\setlist[enumerate]{noitemsep, topsep=0pt}

\graphicspath{ {./images/} }

\chapternumberfont{\Large}
\chaptertitlefont{\huge}

\usepackage[font={normalsize,it}]{caption}

\linespread{1.5}
\usepackage[table]{xcolor}
\usepackage{longtable}
\usepackage{fourier} 
\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}

\usepackage[a4paper, bindingoffset=1cm, margin=2.5cm]{geometry}
\widowpenalty10000
\clubpenalty10000

%--------------------------------------------------------------------
% Numeracja stron 
%--------------------------------------------------------------------

\pagenumbering{arabic}

\RequirePackage{fancyhdr}

\fancypagestyle{plain}{
  \fancyhf{}
  \fancyfoot[C]{\fontsize{9pt}{9pt}\selectfont\thepage}%
   \renewcommand{\headrulewidth}{0.0pt}
}

\pagestyle{plain}

\begin{document}
\chapter*{Pusta strona 1}
\chapter*{Pusta strona 2}
%dodanie nienumerowanych rozdziałów do spisu treści
\addcontentsline{toc}{chapter}{Streszczenie}
\addcontentsline{toc}{chapter}{Wykaz najważniejszych oznaczeń i skrótów}
\renewcommand{\familydefault}{\sfdefault}
\chapter*{Streszczenie}
(maksymalnie 1 strona)\par
(strona nr 3 – numer widoczny)\par
Xxxxxxxx xxxxxxx xxxxxxxx xxxxxxxxxxxx xxxxxxxx x xxxxxxxxx. Xxxxx xxxxxxxxx xxxx xxxxxx xxxxx. Xxxxxxxx xxxxxxx xxxxxxxx xxxxxxxxxxxx xxxxxxxx x xxxxxxxxx. Xxxxxxxx xxxxxxx xxxxxxxx xxxxxxxxxxxx xxxxxxxx x xxxxxxxxx. 
\newline\textbf{Słowa kluczowe}: xxxxxxx, xxxxxxxx
\newline\textbf{Dziedzina nauki i techniki, zgodnie z wymogami OECD}: 
dziedzina, technika, …
\newline ABSTRACT (maksymalnie 1 strona)
\par Xxxxxxxx xxxxxxx xxxxxxxx xxxxxxxxxxxx xxxxxxxx x xxxxxxxxx. Xxxxx xxxxxxxxx xxxx xxxxxx xxxxx. Xxxxxxxx xxxxxxx xxxxxxxx xxxxxxxxxxxx xxxxxxxx x xxxxxxxxx. Xxxxxxxx xxxxxxx xxxxxxxx xxxxxxxxxxxx xxxxxxxx x xxxxxxxxx.
\newline\textbf{Keywords}: xxxxxxx, xxxxxxxx

\tableofcontents
\chapter*{Wykaz najważniejszych oznaczeń i skrótów}
\noindent REST (Representational State Transfer) - transfer stanu przez reprezentację \\
JSON (JavaScript Object Notation) - obiektowy sposób zapisu danych \\
JWT (JSON Web Token) - token w formacie JSON używany w celu zabezpieczenia dostępu aplikacji \\
API (Application Programming Interface) - interfejs aplikacji dostępny dla programisty \\
MVP (Model View Presenter) - wzorzec architektoniczny\\


\chapter{Wstęp i cel pracy}  
xxxxx
\chapter{Przegląd podobnych rozwiązań} 
Aplikacje do planowania podróży to często spotykane rozwiązanie ułatwiające organizowanie wyjazdów. Oferowane są dla systemów operacyjnych Android oraz iOS odpowiednio w serwisach Google Play i Apple Store. Przetestowano 4 przykładowe aplikacje, których podstawowe dane zawiera tabela~\ref{tab:porównianie}.

\captionof{table}{Dane testowanych aplikacji\label{tab:porównianie}}

\begin{center}
\begin{tabular}{ |c|c|c|c| }
\hline
\multirow{2}{6em}{\thead{\makecell{Nazwa \\ aplikacji}}} & \multicolumn{2}{c|}{\thead{Google Play}} & \thead{Apple Store}\\
\cline{2-4}
 & Średnia ocena & Ilość pobrań & Średnia ocena \\
\hline
TripIt: Travel Planner & \makecell{4.4/5 \\ (53217 ocen)} & ponad 1 mln & 4.8/5 (122.9K ocen) \\
\hline
Google Trips - Travel Planner & \makecell{4.1/5 \\ (30473 ocen)} & ponad 5 mln & 4.4/5 (3100 ocen) \\
\hline
Sygic Travel: Planuj Podróż & \makecell{4.2/5 \\ (10637 ocen)} & ponad 1 mln & 4.6/5 (1600 ocen) \\
\hline
Expedia & \makecell{4.2/5 \\ (172035 ocen)} & ponad 10 mln & 4.8/5 (551.9K ocen) \\
\hline
\end{tabular}
\end{center}

\section{Aplikacja TripIt: Travel Planner (Dorota Tomczak)}
\par TripIt to aplikacja do planowania podróży, którą przetestowano na urządzeniu z systemem operacyjnym iOS. Dostępna była jedynie w języku angielskim. Podstawowa wersja aplikacji była darmowa, natomiast wersję rozszerzoną (TripIt Pro) oferowano w formie subskrypcji, która kosztowała 49\$ rocznie. Oprócz tego istniała też opcja TripIt for Teams, która pozwalała na planowanie podróży grupy osób.
\par Aby móc korzystać z aplikacji trzeba było najpierw założyć konto w serwisie TripIt, co jednak pozwalało na dostęp do wszystkich swoich planów podróży na różnych urządzeniach. Opcjonalne było natomiast zezwolenie na automatyczne przesyłanie wiadomości e-mail ze swojej skrzynki pocztowej na adres plans@tripit.com. Po umożliwieniu tej opcji, TripIt kilka razy dziennie sprawdzało skrzynkę użytkownika, by następnie pobrać z niej informacje o rezerwacjach lotów, hoteli, samochodów i dodać je do planu podróży.
\par Stworzenie nowego planu podróży było bardzo proste. Wymagało podania miasta docelowego wyjazdu oraz zakresu dat, w których podróż miała się odbyć. Dodatkowo można było dodać ogólną nazwę wyprawy oraz jej opis. Po zalogowaniu do aplikacji na ekranie widoczne były  nadchodzące podróże, a po przełączeniu zakładki również te już odbyte. Obok informacji o nazwie bądź celu podróży, jej terminie i czasu trwania wyświetlało się zdjęcie przedstawiające miasto docelowe podróży, albo zdjęcie samolotu dla miast, których aplikacja zdjęć nie posiadała. Każdą podróż można było usunąć, edytować, scalić z inną oraz dodać do niej plan. 

\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{tripit1}
\caption{Plan podróży.}
\label{fig:TIsubim1}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{tripit2}
\caption{Opcje transportu taksówką.}
\label{fig:TIsubim2}
\end{subfigure}
\caption{TripIt: Travel Planner.}
\label{fig:TIimage1}
\end{figure}

\par Oprócz wspomnianego wcześniej automatycznego dodawania rezerwacji i planów przez aplikację po pobraniu tych informacji ze skrzynki pocztowej, można to też było zrobić manualnie. TripIt oferowało 18 różnych elementów, które można było dodać do planu, między innymi: lot (ang. flight), kwatera (ang. lodging), wynajem samochodu (ang. car rental), teatr (ang. theater), rejs (ang. cruise), transport (ang. transportation) i ogólna aktywność (ang. activity). Poszczególne elementy umożliwiały dodanie różnych informacji o planowanej podróży, jednak każdy z nich wymagał dodania daty i godziny do danej aktywności, aby aplikacja mogła je później zorganizować chronologicznie. Przy wpisywaniu niektórych informacji aplikacja podpowiadała jakie słowa mógł mieć na myśli użytkownik, co bywało pomocne. Było tak na przykład w przypadku wpisywania nazwy linii lotniczych i nazwy restauracji, a także w przypadku wybrania pola przeznaczonego na podanie adresu. Była to usługa dostarczana przez firmę Google. Po wybraniu takiego zasugerowanego słowa TripIt często samodzielnie uzupełniał niektóre informacje, takie jak np. adres strony internetowej danego obiektu, czy godzina odprawy samolotowej.
Po dodaniu nowego elementu do planu podróży można go było edytować, usunąć, przenieść do innego planu lub uzupełnić o szczegóły, które nie były dostępne przy tworzeniu np. informacje o rezerwacji (ang. booking info), zdjęcia (ang. photos), uczestnicy (ang. attendees). Dla każdego elementu dostępny był również nawigator (ang. navigator), który po wybraniu miejsca startowego i docelowego wyszukuje możliwe opcje transportu z szacowanym czasem ich trwania i kosztem (w dolarach). Po wybraniu transportu samochodem lub pieszo, aplikacja TripIt przekierowywała do aplikacji Google Maps, gdzie można było zobaczyć wyznaczoną trasę.

\par Ciekawą funkcją było pozyskiwanie informacji o okolicy (ang. neighborhood info), w której znajdował się dodany obiekt. Usługa ta była dostarczana przez GeoSure i udostępniała wskaźniki między innymi z takich kategorii jak: ogólne bezpieczeństwo (ang. overall safety), ryzyko doznania krzywdy fizycznej (ang. physical harm), ryzyko kradzieży (ang. theft). Poza tym TripIt oferowała też wyświetlenie miejsc, będących w pobliżu obiektu z kilku kategorii: restauracje, kawiarnie, bary, bankomaty, parkingi. Wyszukane miejsca pokazywały się na mapie, a po wybraniu jednego z nich można było między innymi zobaczyć godziny otwarcia oraz dodać je do swojego planu podróży.

\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{tripit3}
\caption{Wyszukanie pobliskich kawiarni.}
\label{fig:TIsubim3}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{tripit4}
\caption{Udostępnianie planu podróży.}
\label{fig:TIsubim4}
\end{subfigure}
\caption{TripIt: Travel Planner.}
\label{fig:TIimage2}
\end{figure}

\par Każdy plan lub element podróży można było udostępnić lub zapisać w formacie txt. Wybierając opcję Invite Others to View Trip, plan podróży wysyłano na wybrany adres mailowy (który może zostać wyszukany poprzez kontakty) osoby, której można nadać jedno z trzech uprawnień: can view, can edit, can edit and is traveling. W tak wysłanej wiadomości znajdował się link do planu podróży wraz z mapą, które można było wyświetlić w przeglądarce lub aplikacji. W przeglądarce wyświetlała się dodatkowo informacja o pogodzie na każdy dzień podróży. Osoby, którym nadano odpowiednie uprawnienia i posiadały one konto w serwisie TripIt, mogły edytować udostępniony im plan podróży.

\par W aplikacji można było przechowywać informacje o swoich dokumentach i kontaktach, które mogły się przydać w razie nieprzewidzianych sytuacji. Dane te były dostępne po wprowadzeniu 4-cyfrowego pinu, który należało uprzednio ustawić. W ustawieniach można było włączyć synchronizację kalendarza na naszym urządzeniu z aplikacją TripIt, co powodowało automatyczne dodawanie informacji o planie podróży z aplikacji do kalendarza. Dodatkowo w aplikacji można było obejrzeć statystyki ze wszystkich swoich podróży, takie jak liczba przebytych kilometrów, liczba odwiedzonych krajów i inne.

\par Opisane wyżej funkcje dotyczyły darmowej wersji aplikacji TripIt. Wersja Pro rozszerzała tą wersję przede wszystkim o rozbudowany system powiadomień oraz mechanizmów śledzących (ang. trackers). Niektóre z tych udogodnień to: powiadomienia o dostępności lepszych miejsc w samolocie, przypomnienia o konieczności odprawy 24 godziny przed wylotem, wyszukiwanie alternatywnych połączeń, wysyłanie informacji o locie w czasie rzeczywistym podczas całej podróży, udostępnianie interaktywnych map lotniska. Wersję TripIt Pro można było przetestować za darmo przez 30 dni.

\par Aplikacja TripIt oferowała wiele możliwości w planowaniu swoich podróży, co pozwalało na stworzenie bardzo szczegółowych planów. Wiele informacji trzeba było wprowadzać samodzielnie, jednak aplikacja często podpowiadała jakie słowa mógł mieć na myśli użytkownik, co znacznie ułatwiało i przyspieszało ten proces. Dodatkowym ułatwieniem była funkcja automatycznego dodawania danych o rezerwacjach, które mogły być pobierane ze skrzynki pocztowej. Dużą zaletą aplikacji była również opcja wyznaczania trasy między dwoma punktami, jednak koszt takiej wyprawy podawany był tylko w dolarach amerykańskich bez względu na kraj, w którym odbywała się podróż i miejsce zamieszkania użytkownika. TripIt pozwalała w łatwy sposób wyszukać sąsiednie obiekty, takie jak restauracje, czy parkingi, jednak brakowało tu atrakcji turystycznych, a odległość od tych obiektów podawana była w stopach (ft) i nie dało się tego zmienić. Z pewnością przydatną funkcją była możliwość udostępnienia stworzonego przez siebie planu innym osobom, jednak by wysłać link ze sformatowanym planem można było to zrobić jedynie na adres mailowy, a nie przez inne środki komunikacji, gdzie wysłany plan był dostępny wyłącznie w formie tekstowej. Wadą aplikacji była jej dostępność jedynie w języku angielskim. Ponadto cena wersji PRO, która wprowadzała szereg dodatkowych udogodnień, była wysoka i mogła odstraszać potencjalnego użytkownika.

\section{Aplikacja Google Trips - Travel Planner (Karolina Makuch)}

\par Aplikacja Google Trips – Travel Planner była dostępna na urządzenia mobilne z systemem iOS oraz Android. Była jedną z popularniejszych aplikacji w Sklepie PLAY. Google Trips była także dostępne w Apple Store. 
\par W celu korzystania z Google Trips należało posiadać konto Google. Umożliwiło to dostęp do planu podróży z różnych urządzeń. Niestety aplikacja miała jeden wariant językowy (język angielski).
\par Na samym początku należało wybrać miasto docelowe. Po wyszukaniu miasta, użytkownik miał możliwość nazwania swojej wycieczki oraz dodawania poszczególnych etapów podróży, uwzględniając przedział czasu poświęcony na każdy z nich.

\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{googletrips1}
\caption{Tworzenie nowej podróży}
\label{fig:GTsubim1}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{googletrips2}
\caption{Przeglądanie mapy z polecanymi obiektami}
\label{fig:GTsubim2}
\end{subfigure}
\caption{Google Trips - Travel Planner.}
\label{fig:GTimage1}
\end{figure}

\par Aplikacja umożliwiała zapisywanie rezerwacji (ang. Reservations) lotu (ang. Flight), hotelu (ang. Hotel), pociągu (ang. Train), autobusu (ang. Bus), samochodu (ang. Car rental) oraz restauracji (ang. Restaurant). W zależności od rodzaju transportu użytkownik uzupełniał odpowiednie informacje takie jak: skąd chce się wybrać, dokąd, kiedy, o której godzinie, numer telefonu, numer potwierdzający,miejsca pasażerów oraz rodzaj transportu. Google Trips posiadał także Notatnik posiadający ograniczenie do 10 000 słów.
\par Kolejną opcją była możliwość przejrzenia oraz zapisania dostępnych atrakcji (ang. Things to do). Zostały one podzielone na kilka podkategorii na przykład : polecane (ang. Top Spots), preferowane (ang. For you), parki (ang. Parks \& gardens), muzea (ang. Museums), w pomieszczeniu (ang. Indoors), na świeżym powietrzu (ang.outdoor), przyjazne dzieciom (ang. Kids friendly) oraz okoliczne atrakcje (ang. Farther away). Po wybraniu interesującej użytkownika atrakcji użytkownik mógł zobaczyć fotografię, która została wykonana atrakcji,a także miał możliwość przeczytania opisu oraz recenzji użytkowników. Umieszczony był także adres, numer telefonu oraz adres strony internetowej. Aplikacja umożliwiała także nawigację do danej atrakcji. Po naciśnięciu mapy(górny prawy róg) użytkownik mógł zobaczyć lokalizację atrakcji na planie miasta. Daną atrakcję można było zapisać na jednej z domyślnych list: ulubione(ang.favorites), planowane do odwiedzenia (ang. Want to go) oraz ocenione (ang.starred place). Istniała także możliwość stworzenia własnej listy poprzez podanie nazwy.

\par Następny kafelek umożliwiał przejrzenie zapisanych wcześniej atrakcji oraz wyświetlenie ich w wspomnianych wcześniej listach.

\par Aplikacja układała także sugerowane plany dnia (ang. Day plans). Każdy z nich otrzymał własną nazwę. Składał się z mapy,a także ilości oraz odnośników do poszczególnych atrakcji. Aplikacja udzielała użytkownikowi wskazówek odnośnie godzin i dni otwarcia danych atrakcji, ile czasu zazwyczaj spędzają tam zwiedzający, a także jak dużo czasu zajmie przejście do kolejnego punktu z planu.

\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{googletrips3}
\caption{Przeglądanie planu dnia}
\label{fig:GTsubim3}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{googletrips4}
\caption{Przeglądanie informacji na temat regionalnej kuchni}
\label{fig:GTsubim4}
\end{subfigure}
\caption{Google Trips - Travel Planner.}
\label{fig:GTimage2}
\end{figure}

\par Korzystanie z aplikacji umożliwiało użytkownikom otrzymanie zniżek na poszczególne usługi na przykład: taksówki (pre-booked taxis) czy wypożyczenie samochodu (car hire).
Aplikacja posiadała także informacje na temat lokalnej kuchni (kafelek Food \& Drink). Zawierał on krótki opis charakterystycznej dla danego rejonu kuchni, wypunktowane lokalne specjalności kuchni(ang.local specialities), polecane miejsca do jedzenia „na mieście” (ang. Dining out) , a także wskazówki na temat ‘”nocnego życia” (ang. Nightlife). Zakładka „Top Spots” zawierała najbardziej polecane miejsca w poszczególnych kategoriach: ekskluzywne posiłki (ang.high-end dining), budżetowe posiłki (ang. on a budget), miejsca przyjazne rodzinom (ang.family-friendly), śniadania i przekąski (ang. breakfast \& brunch), obiady(ang.lunch),posiłki wegetariańskie (ang.vegetarian-friendly),bary (ang.vodka bars), piwowarnie kraftowe (ang.craft beer) oraz kawiarnie tematyczne(ang.themed cafes). Po wybraniu danej kategorii istniała opcja sortowania propozycji według odległości. Można było także przefiltrować wyniki ze względu na godziny otwarcia (ang. Open now) a także wcześniej zapisanych pozycji (ang. only saved places).
\par Kafelek Zwiedzaj (ang. getting around) umożliwiał sprawdzenie poszczególnych kategorii transportu: on arrival (taxi, ride service, train, bus), public transport (ticket, metro, bus, train, tram), taxi (ang. taxi/ride service), driving, walking \& biking. Każda kategoria była wystarczająco szczegółowo opisana. Zawierała informacje na temat cen, możliwości dojazdu, czasu trwania, możliwych korkach oraz na przykład numerów telefonów do taksówek.
\par Aplikacja zawierała także wskazówki związane z zakupami (ang. Need to know). Informowała użytkownika o najpopularniejszych godzinach otwarcia sklepów, gdzie znajduje się najwięcej sklepów (ang. Shopping districts). Można było tam także znaleźć przykładowe sklepy (ang. Markets) oraz galerie handlowe (ang. Malls).
 
\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{googletrips5}
\caption{Przeglądanie możliwości transportu}
\label{fig:GTsubim5}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{googletrips6}
\caption{Przeglądanie przydatnych informacji}
\label{fig:GTsubim6}
\end{subfigure}
\caption{Google Trips - Travel Planner.}
\label{fig:GTimage3}
\end{figure}

\par Zaplanowana przez użytkownika wycieczka została automatycznie przypisana do konta Google. Istniała możliwość udostępnienia jej znajomym. Można było połączyć kilka wycieczek. Po pobraniu informacji na temat danej wycieczki, istniała możliwość powrotu do planu, gdy telefon jest offline.
\par Niestety aplikacja była dostępna tylko w języku angielskim. Posiadała także kilka innych wad. Podczas wyszukiwania odpowiedniego hotelu aplikacja wyświetla listę miejsc. Przykładowo przy wyszukiwaniu hotelu można było wybrać sklep meblowy. Brakowało także podpowiedzi przy niektórych polach np. cartype. Aplikacja nie zawsze dodawała informacje z serwisu gmail. Nie można było samemu dodać atrakcji za pomocą informacji z Google Maps,a także dodać ręcznie maili z rezerwacjami.

\section{Sygic Travel - Planuj podróż (Anna Malizjusz)}

\par Planowanie podróży umożliwia również aplikacja Sygic Travel: Planuj Podróż, która została pobrana z serwisu Google Play. Jej duża zaleta to możliwość korzystania z większości funkcji w języku polskim oraz brak konieczności tworzenia konta. Jedyną opcją niedostępną dla niezalogowanego użytkownika była synchronizacja z innymi urządzeniami.
\par Podstawowymi informacjami potrzebnymi do rozpoczęcia planowania podróży były cel, data rozpoczęcia oraz data zakończenia (rys.~\ref{fig:STsubim1}). Opcjonalnie można było podać miejsce przybycia oraz zakwaterowania. Wygodny wybór daty umożliwił wyświetlany kalendarz, a miejsca należało wybrać z podanej listy. Istniała również możliwość filtrowania podanych miejsc po nazwie.
\par Po stworzeniu podróży został wyświetlony interfejs oferujący różne opcje (rys.~\ref{fig:STsubim2}). Po wybraniu mapy można zobaczyć mapę miejsca docelowego z zaznaczonymi atrakcjami. Listę atrakcji można też zobaczyć wybierając opcję miejsca. W obu przypadkach można wybrać kategorie, np. zwiedzanie, zakupy, relaks oraz tagi, np. zwierzęta mile widziane (ang. pets allowed), a także możliwe było dodanie miejsca do odwiedzenia w danym dniu. Dodatkowo zaprezentowano szacunkowy czas dotarcia do celu piechotą z miejsca zakwaterowania. Ta część aplikacji nie została przetłumaczona i była dostępna tylko w języku angielskim. Analogicznie można było przeglądać dostępne kwatery po wybraniu opcji hotele. Dostępne były typowe opcje pomocne w poszukiwaniu zakwaterowania, takie jak wybór średniej oceny, przyznanych gwiazdek, typu zakwaterowania czy udogodnień, np. darmowe Wi-Fi (ang. free hotel Wi-Fi) lub klimatyzacja (ang. air conditioning).
\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{sygictravel1}
\caption{Tworzenie nowej podróży.}
\label{fig:STsubim1}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{sygictravel2}
\caption{Menu główne.}
\label{fig:STsubim2}
\end{subfigure}
\caption{Sygic Travel - Planuj podróż.}
\label{fig:STimage}
\end{figure}
\par Innego typu funkcjami aplikacji były wycieczki i aktywności oraz wynajem samochodów. Pierwsza opcja umożliwiała wyszukiwanie wycieczek, a także ich rezerwację oraz płatność. Druga wyszukiwała oferty wynajmu samochodów, wyświetlała wszystkie dostępne informacje oraz umożliwiała rezerwację. W obu funkcjach udostępniono możliwość filtrowania wyników. Poważną wadą wyszukiwarki samochodów do wynajęcia stanowił niejasny komunikat o błędzie w przypadku podania dat z przeszłości, który sugerował sprawdzenie zaznaczonych pól nie wskazując możliwego rozwiązania problemu.
\par Kolejna ciekawa opcja to wycieczka wideo (ang. video tour), która była dostępna tylko dla bardziej popularnych celów podróży. Po wybraniu tej opcji użytkownikowi wyświetlany był film wraz z angielskim komentarzem z jednodniowej wycieczki po wybranym mieście. Prezentowano charakterystyczne i warte odwiedzenia zabytki i atrakcje turystyczne, a użytkownikowi umożliwiono ingerowanie w pokazywany obraz. Filmy oferowały widok 360° po obróceniu telefonu.
\par 3 kolejne funkcje były czysto informacyjne, lecz przydatne. Pokazywały prognozę pogody na najbliższe 14 dni, a także informacje o mieście i okolicy. Obszerność tych danych różniła się w zależności od popularności celu podróży, ale mogła stanowić dobrą podstawę dla nieobeznanych z miejscem użytkowników. Informacje w języku angielskim zostały zaczerpnięte z serwisu Wikivoyage, który można otworzyć w aplikacji oraz przeglądarce internetowej.
\par Po zakupie Sygic Travel Premium za 88,99 zł pojawiały się dodatkowe funkcjonalności, takie jak zapisanie mapy miejsca docelowego do użytku offline. Kolejną opcją było wyświetlenie informacji o zabytkach, hotelach i atrakcjach, których odwiedzenie proponowała aplikacja. Darmowa wersja oferowała wszystkie najbardziej potrzebne opcje, więc zakup rozszerzonej wersji nie był koniecznością, a jedynie nieznacznym zwiększeniem możliwości aplikacji.
\par Aplikacja została zintegrowana z innymi produktami firmy Sygic. Przy każdym miejscu oferowała możliwość nawigacji przy pomocy Sygic GPS Navigation \& Maps, a rezerwacja wycieczek i samochodów była wspierana przez witrynę Sygic Travel, która była dostępna również z komputera z przeglądarki internetowej.
\par Sygic Travel to spełniające podstawowe funkcje narzędzie ułatwiające planowanie podróży. Nie oferowała wielu możliwości, jednak warto zauważyć, że większość z nich była dostępna w wersji podstawowej i nie zmuszała użytkownika do zakupu stosunkowo drogiej wersji premium. Udostępniała bogaty wybór możliwych do odwiedzenia miejsc w wybranym celu podróży, a sam cel mógł należeć do egzotycznych, np. Udaipur w Indiach. Podstawowe informacje, takie jak mapa, atrakcje turystyczne czy prognoza pogody były zawsze dostępne. 

\section{Expedia (Magdalena Solecka)}
\par Kolejna aplikacja do planowania podróży to Expedia, dostępna na urządzeniach z systemem iOS oraz Android. Korzystanie z niej było możliwe po założeniu konta użytkownika. Wśród dostępnych tłumaczeń nie znajdował się język polski. Aplikacja składała się z czterech głównych funkcjonalności: rezerwacja noclegu (ang. Hotels), rezerwacja lotu (ang. Flights), rezerwacja samochodu (ang. Cars) oraz wyszukiwanie ciekawych miejsc w okolicy (ang. Thing to Do). Nie było możliwości wyszukania restauracji w rejonie ani transportu naziemnego, koleją lub autobusem.
\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{expedia1}
\caption{Menu główne.}
\label{fig:Esubim1}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{expedia2}
\caption{Wyszukiwanie noclegu.}
\label{fig:Esubim2}
\end{subfigure}
\caption{Expedia.}
\label{fig:Eimage}
\end{figure}
\par W celu wyszukania noclegu należało podać następujące dane: datę zameldowania i wymeldowania, miasto docelowe podróży, liczbę pokoi oraz osób do zakwaterowania. Zaprezentowane przez aplikację wyniki mogły zostać posortowane po cenie lub recenzjach użytkowników, a także przefiltrowane względem darmowego anulowania rezerwacji, śniadaniu wliczonym w cenę pobytu, klimatyzacją czy Wi-Fi. Wygodnym rozwiązaniem była mapka z naniesionymi na nią punktami z ceną w miejscu, w którym znajdował się oferowany pokój, co umożliwiało łatwiejszą ocenę odległości od centrum.
\par W przypadku rezerwacji miejsca w samolocie można było wyszukać lot w jedną lub obie strony. Należało podać miejsce wylotu i przylotu oraz daty. Przedstawione wyniki można było porządkować według rosnącego kosztu. Aplikacja nie dawała możliwości porównania cen w różnych dniach np. w formie kalendarza uzupełnionego najniższymi cenami w danym dniu, co przy podróżowaniu z niskim budżetem byłoby pomocne. Możliwe było równoczesne wyszukanie lotów oraz noclegu (ang. Bundle Deals).
\par Aplikacja oferowała również możliwość wypożyczenia samochodu. Tak jak w poprzednich dwóch przypadkach należało podać przedział czasu korzystania z pojazdu, miejsce odbioru i pozostawienia. Wyświetlone informacje o pojazdach były przydatne przy dokonywaniu wyboru, automatyczna czy manualna skrzynia biegów, ilość pasażerów.Dostępne sortowanie po cenie.
\par Ostatnia funkcjonalność, wyszukiwanie atrakcji, zabytków, ciekawych wydarzeń. Wymagane ramy czasowe oraz lokalizacja. Rezultaty mogły być przeglądane po cenie lub popularności. Nie umożliwiono użytkownikowi oceny odległości między zaproponowanymi miejscami tak jak w przypadku noclegu, ale pomocny był przybliżony czas, który należy przeznaczyć na każdą z atrakcji.
\par Wszystkie rezerwacje wykonane za pomocą aplikacji Expedia, można było przeglądać w zakładce Wycieczki (ang. Trips) i takim zestawem dzielić się ze współtowarzyszami podróży również korzystających z aplikacji.

\chapter{Specyfikacja wymagań systemowych - ekstrakt (Anna Malizjusz)}
\par W celu lepszego zrozumienia wymagań projektu inżynierskiego przygotowano dokument SWS (Specyfikacji Wymagań Systemowych) w całości umieszczony na załączonej do pracy płycie~CD. Dokonano identyfikacji udziałowców projektu i otoczenia systemu z uwzględnieniem użytkowników oraz systemów zewnętrznych. Wyróżniono cele projektu oraz wymagania, których spełnienie będzie kluczowe dla końcowej akceptacji systemu. Poniżej przedstawiono najistotniejsze elementy SWS, które miały największy wpływ na projekt i~implementacje systemu.
\newline
\newline
\noindent Wyróżniono udziałowców, których wpływ na system powinien być największy:

\begin{itemize}
\item programiści,
\item promotor,
\item użytkownik.
\end{itemize}

\noindent A także dokumenty, które należało uwzględnić w pracy:

\begin{itemize}
\item regulamin aplikacji,
\item rozporządzenie o ochronie danych osobowych (RODO).
\end{itemize}

\par Docelowego użytkownika zidentyfikowano jako młodego człowieka, najczęściej studenta o ograniczonym budżecie i czasie, który może poświęcić na planowanie podróży. Posiada on smartfona z dostępem do internetu oraz używa systemu operacyjnego Android. Chce podróżować i kontaktować się z przyjaciółmi poprzez aplikację. Często zapomina o terminach i~koniecznych dokumentach, więc potrzebuje przypomnień oraz dostępu do skanów przy pomocy telefonu.

\par Wyróżniono systemy zewnętrzne, z którymi zintegrowano aplikację. Skupiono się na dostępie do zewnętrznego API udostępnionego przez serwis Here \cite{Here}, które umożliwiało dostęp do map, nawigacji i wyszukiwania obiektów takich jak hotele, restauracje, zabytki, itp. Zaletą serwisu był darmowy dostęp do danych. Here umożliwiało wykonanie 250 tys. zapytań miesięcznie bez dodatkowych opłat, a każdy kolejny tysiąc kosztował 1\$, co zostało uznane za wystarczające dla testowania aplikacji. Uwzględniono również system GPS, który był niezbędny do zrealizowania podstawowych funkcjonalności, np.~wyszukiwania obiektów w pobliżu aktualnej lokalizacji. W tym celu zdecydowano skorzystać z możliwości oferowanych przez serwis Google Play w paczce \textit{com.google.android.gms.location}\cite{gms.location}.

\par
\noindent \newline Określono najważniejsze cele projektu:

\begin{itemize}
\item zwiększenie zadowolenia z podróży,
\item zaspokajanie potrzeb informacyjnych użytkowników,
\item zoptymalizowanie trasy,
\item zmniejszenie ilości spóźnień,
\item ułatwienie komunikacji pomiędzy użytkownikami,
\item ułatwienie możliwości koordynacji planu dnia przez użytkownika,
\item skrócenie czasu oczekiwania na dany środek transportu,
\item zmniejszenie czasu przeznaczonego na planowanie podróży,
\item zmniejszenie poziomu stresu użytkowników podczas planowania podróży.
\end{itemize}

\par
\noindent\newline Zidentyfikowano wymagania funkcjonalne, które jednocześnie stanowiły kryteria akceptacyjne projektu: 

\begin{itemize}
\item rejestracja i logowanie użytkownika,
\item dodanie, przeglądanie i edycja planu podróży i planu dnia,
\item wyszukanie elementu w pobliżu danej lokalizacji,
\item wygenerowanie planu dnia/podróży,
\item wyszukanie i zaproszenie innego użytkownika do wyświetlania lub edycji podróży,
\item dodanie oceny do planu dnia, podróży lub odwiedzonego miejsca,
\item otrzymanie propozycji na podstawie ocen,
\item wyszukanie transportu między lokalizacjami,
\item wyszukanie najkrótszej trasy,
\item skanowanie biletów i innych dokumentów potrzebnych w trakcie podróży,
\item zapisywanie podróży i dokumentów na urządzeniu, aby możliwe było korzystanie z nich bez dostępu do internetu.
\end{itemize}

\par
\noindent Wyróźniono dodatkowe wymagania, które nie były niezbędne do realizacji projektu, ale znacznie zwiększały możliwości aplikacji: 

\begin{itemize}
\item wyszukanie zakwaterowania,
\item powiadomienie o obiekcie w okolicy,
\item powiadomienie o opóźnieniu,
\item oznaczenie elementu z planu dnia jako wykonany,
\item powiadomienia dotyczące lotów,
\item przeglądanie statystyk zrealizowanych podróży,
\item udostępnianie zrealizowanego punktu planu dnia w mediach społecznościowych.
\end{itemize}

\par Dodatkowo zostały określone wymagania jakościowe dotyczące aplikacji. Ze względu na RODO przetwarzanie danych użytkowników ograniczono do minimum i~zdecydowano o wyświetlaniu użytkownikom informacji o sposobie używania danych. Postanowiono skorzystać z bezpiecznych algorytmów szyfrowania i uwierzytelniania, aby zapewnić danym bezpieczeństwo. 
Zobowiązano się do zapewnienia autentyczności proponowanych podróży, tj. sugerowany czas spędzony w danym obiekcie jest zbliżony do rzeczywistego i trafności polecanych obiektów. Zapytania użytkowników mają być obsługiwane nie dłużej niż 5~s., a układanie planu dnia będzie trwać maksymalnie 10~s.

\par Za docelowe urządzenie przyjęto smartfon z systemem operacyjnym Android, którego minimalna wersja to 5.0 (Lollipop), co miało zapewnić obsługę ponad 94\% urządzeń z systemem Android (dane aktualne na dzień 05.05.2019\cite{Android usage}). Spodziewane wymiary urządzeń to od~115.20~mm~x~58.60~mm do~242,8~mm~x~189,7~mm. Zaplanowano rozszerzenie działania aplikacji na telefony z systemem operacyjnym iOS.

\par Zwrócono uwagę na zagwarantowanie czytelności interfejsu użytkownika. Zaplanowano użycie stonowanych, niejaskrawych kolorów i ograniczenie dostępnych informacji na jednym ekranie z możliwością przejścia do kolejnych stron lub filtrowania wyników. Dostępne ma być powiększenie ekranu.

\chapter{Projekt systemu (Magdalena Solecka)}
\par System postanowiono podzielić na następujące komponenty:
\begin{itemize}
\item Po stronie serwera:
\begin{itemize}
\item Podsystem planowania (ang. Planning subsystem)
\item Podsystem wyszukiwania (ang. Search subsystem)
\item Podsystem zarządzania danymi użytkownika (ang. User Data Management Subsystem)
\item Podsystem polecający (ang. Recommendation Subsystem)
\item Podsystem usług społecznościowych (ang. Social Services Subsystem)
\item Podsystem zarządzania (ang. Management Subsystem)
\end{itemize}
\item Po stronie aplikacji mobilnej:
\begin{itemize}
\item GUI
\item Prezenter (ang. Presenter)
\item Podsystem zarządzania plikami (ang. File Management Subsystem)
\item Podsystem skanowania (ang. Scanning Subsystem)
\end{itemize}
\end{itemize}
\par Kontakt klienta mobilnego z aplikacją serwerową zaplanowano poprzez interfejs komunikacji (ang. communication interface). Zależności pomiędzy podsystemami zostały przedstawione na diagramie (rys.~\ref{fig:subsystems}).

\indent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{subsystems}
\caption{Diagram komponentow systemu.}
\label{fig:subsystems}
\end{figure}

\section{Scenariusze użycia}
\par Zaprojektowano scenariusze użycia w celu dokładnego określenia sposobów, w które użytkownicy będą korzystać z aplikacji. Wyróżniono najważniejsze:
\begin{enumerate}
  \item Stworzenie planu dnia.
  \item Wygenerowanie planu dnia.
  \item Stworzenie planu podróży.
  \item Interakcje z innymi użytkownikami aplikacji.
  \item Interakcje serwera z aplikacją w czasie trwania podróży.
\end{enumerate}

\subsection{Stworzenie planu dnia (Magdalena Solecka)}
\par Martyna widzi pusty ekran planu dnia. Wpisuje miasto docelowe wyjazdu - Paryż. Wybiera przycisk "+" i wybiera atrakcje. Ukazuje się przed ną ekran wyszukiwania ze znakiem wyszukiwania,a po chwili z wynikami wyszukiwania w formie listy atrakcji. Wybiera jeden z elementów listy – katedra Notre Dame i czyta jej opis. Wybiera przycisk "Dodaj". Widzi ponownie ekran planu Dnia z dodaną przez siebie atrakcją. Wybiera w ten sposób kilka kolejnych atrakcji. Ponownie wybiera przycisk "+" i wybiera restauracje. Ponownie widzi ekran wyszukiwania z listą restauracji. Wybiera pasujący jej obiekt i przy użyciu przycisku "Dodaj" zostaje on dodany do  planu dnia który ponownie wyświetla się przed nią. Użytkownik wybiera przycisk "Ułóż" i czeka aż aplikacja zakończy obliczanie najbardziej optymalnej trasy. Po kilku sekundach plan dnia jest już gotowy. Martyna stwierdza jednak że potrzebuje w ciągu dnia odpoczynku dlatego postanawia przesunąć zwiedzanie katedry Notre Dame na następny dzień. Wybiera element z katedrą i przycisk "Przenieś", a następnie numer dnia podróży. Następnie stwierdza, że właściwie nie interesuje jej sztuka sakralna, więc usuwa element z planu przesuwając go w prawo.

\noindent\newline Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Użytkownik wybrał opcję stwórz plan dnia.
\end{enumerate}

\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Użytkownik stworzył plan dnia.
\end{enumerate}

\subsection{Wygenerowanie planu dnia (Anna Malizjusz)}
\par Martyna stworzyła wyjazd, lecz nie ma pomysłu na spędzenie dnia. Wybiera w aplikacji swoją podróż, po czym generuje przyciskiem plan dnia. Zostaje wyświetlony rezultat, który może dowolnie modyfikować. (rys.~\ref{fig:generateDayPlan}).

\noindent Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Użytkownik wybrał podróż.
\end{enumerate}
\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Wyświetlono proponowany plan podróży.
\end{enumerate}

\noindent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{generateDayPlan}
\caption{Generowanie planu dnia.}
\label{fig:generateDayPlan}
\end{figure}
\FloatBarrier


\subsection{Stworzenie planu podróży (Karolina Makuch)}
\FloatBarrier
\par Martyna pragnie zaplanować podróż za pomocą aplikacji poprzez aplikację podróż.  (rys.~\ref{fig:addTravel}).

\noindent\newline Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Użytkownik wybrał opcję stwórz plan podróży.
\end{enumerate}
\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Użytkownik stworzył plan podróży.
\end{enumerate}

\noindent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{addTravel}
\caption{Tworzenie planu podróży.}
\label{fig:addTravel}
\end{figure}

\FloatBarrier
\subsection{Interakcje z innymi użytkownikami aplikacji (Anna Malizjusz)}
\par Martyna wyjeżdża na wakacje razem z~koleżanką, więc chce udostępnić jej swój plan podróży. Zaprasza nowego użytkownika do skorzystania z aplikacji (rys.~\ref{fig:inviteFriend}), po czym dodaje znajomego (rys.~\ref{fig:addFriend}) i~zaprasza koleżankę do edytowania podróży (rys.~\ref{fig:shareTravel}).
\FloatBarrier
\subsubsection{Zapraszanie użytkownika do aplikacji}

\noindent Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Użytkownik wybrał z menu opcję "Znajomi".
\end{enumerate}
\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Wiadomość e-mail została wysłana lub napotkano błąd.
  \item Użytkownik otrzymał informację o pomyślnym wysłaniu zaproszenia lub błędzie.
\end{enumerate}

\noindent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{inviteFriend}
\caption{Zapraszanie użytkownika do skorzystania z aplikacji.}
\label{fig:inviteFriend}
\end{figure}
\FloatBarrier
\subsubsection{Dodawanie znajomego}

\noindent Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Użytkownik wybrał z menu opcję "Znajomi".
\end{enumerate}
\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Użytkownik otrzymał informację o rezultacie.
  \item Drugi użytkownik otrzymał informację zaproszenie.
\end{enumerate}

\noindent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{addFriend}
\caption{Dodanie użytkownika do znajomych.}
\label{fig:addFriend}
\end{figure}
\FloatBarrier
\subsubsection{Udostępnienie podróży}

\noindent Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Użytkownik wybrał podróż do udostępnienia.
  \item Użytkownik docelowy jest znajomym użytkownika udostępniającego.
\end{enumerate}
\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Użytkownik otrzymał informację o rezultacie.
  \item Drugi użytkownik otrzymał informację o udostępnionej podróży.
\end{enumerate}

\noindent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{shareTravel}
\caption{Udostępnienie podróży.}
\label{fig:shareTravel}
\end{figure}

\subsection{Interakcje serwera z aplikacją w czasie trwania podróży (Dorota Tomczak)}
\par Martyna wraz z koleżanką odbywają zaplanowaną poprzez aplikację podróż. W drodze do jednej z atrakcji aplikacja powiadamia Martynę o interesującym obiekcie znajdującym się niedaleko miejsca, w którym przebywają. Dziewczyny ruszają do wskazanej lokalizacji. Tracą poczucie czasu, więc aplikacja informuje je, że jeśli się nie pośpieszą, nie zdążą dojść do następnego punktu planu dnia przed jego zamknięciem (rys.~\ref{fig:whileTravelling}).

\noindent\newline Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Aplikacja ma dostęp do lokalizacji użytkownika.
  \item Użytkownik nie zablokował powiadomień od aplikacji.
  \item Użytkownik utworzył plan podróży i jest w określonym miejscu i czasie.
\end{enumerate}
\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Użytkownik otrzymał odpowiednie powiadomienie.
\end{enumerate}

\noindent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{whileTravelling}
\caption{Otrzymywanie powiadomień podczas trwania podróży.}
\label{fig:whileTravelling}
\end{figure}

\chapter{Decyzje projektowe}

\section{Kotlin <3}

\chapter{Aplikacja mobilna}

\section{Projekt i implementacja oparte na wzorcu MVP (Dorota Tomczak)}
\par Pracę nad aplikacją mobilną rozpoczęto od stworzenia bazowego projektu składającego się na kilka pustych widoków, do których to następnie można było dodawać kolejne funkcjonalności. W celu zachowania najlepszych praktyk programistycznych zdecydowano się na oparciu projektu o wzorzec architektoniczny MVP (ang. model-view-presenter). Jest to wzorzec szczególnie nadający się do implementacji w aplikacjach mobilnych na systemy Android ze względu na aktywności (ang. activity), które pełnią funkcję środkowej warstwy – widoku (ang. view). W implementacji wzorca w tym projekcie widok jest pasywny (ang. passive view) tzn. widok powinien odpowiadać jedynie za wyświetlanie interfejsu i użycie bibliotek związanych z Androidem. Cała logika aplikacji ma być zawarta w prezenterze (ang. presenter), który pełni funkcję kontrolera.

\par Zastosowanie wzorca MVP pozwoliło na zachowanie porządku w strukturze projektu i przejrzysty podział na warstwy. Do każdej aktywności, czyli nowego ekranu w aplikacji, utworzono interfejs zwany kontraktem (ang. contract) zawierający opis interakcji jakie mogą zajść pomiędzy prezenterem a widokiem, a w szczególnych przypadkach również między prezenterem a adapterem, który odpowiada za wyświetlanie listy obiektów. Klasy aktywności i prezentera implementują interfejsy zawarte w kontrakcie, prezenter jest wstrzykiwany do widoku a referencja widoku jest przekazywana do prezentera w konstruktorze.

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{launcherContract}
\caption{Prosty kontrakt widoku odpowiadający za przekierowanie do widoku logowania lub listy podróży.}
\label{fig:launcherContract}
\end{figure}

\par Do wstrzykiwania zależności, w tym prezenterów do aktywności, wykorzystano popularny framework \textit{Dagger 2}\cite{Dagger 2}, co ostatecznie okazało się być nie najlepszym wyborem – należało dodać dwie dodatkowe klasy do każdej aktywności, co przy dużej ich liczbie wygenerowało wiele plików o bardzo podobnej strukturze. Ponadto niemalże jedynymi wstrzykiwanymi obiektami były obiekty klas prezenterów. 

\section{Komunikacja z aplikacją serwerową (Anna Malizjusz)}
\par Aplikacja mobilna musi komunikować się z RESTowym API udostępnianym przez serwer. W tym celu wykorzystano klienta o nazwie Retrofit 2 \cite{Retrofit library}. Dzięki niemu w łatwy sposób można zaimplementować interfejs odpowiedzialny za wysyłanie zapytań i odbieranie odpowiedzi.

\par Napisano kilka klas, aby umożliwić prostą komunikację w aplikacji. Interfejs \textit{ServerApi} zawierał zbiór metod z odpowiednimi adnotacjami @PUT, @POST, @GET, @DELETE i nazwami punktów końcowych. Metody nie wymagały implementacji przez programistów, ponieważ należało to do odpowiedzialności klienta Retrofit 2.

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{serverApi}
\caption{Przykładowa zawartość interfejsu używanego przez Retrofit 2.}
\label{fig:tokenPayload}
\end{figure}

\par Dodatkowo zaimplementowano klasę pomocniczą konfigurującą klienta. Udostępniała ona zmienną (ang. property), która była przygotowanym interfejsem do komunikacji. Ustawiono w niej adres serwera REST, a także konwertery przeprowadzające serializację obiektów do formatu JSON oraz deserializację z otrzymanego ciągu znaków w formacie JSON do obiektu będącego instancją danej klasy. Skorzystano z klasy \textit{GsonConverter}, która jest oferowana przez Retrofit API. Wykorzystano wzorzec projektowy interceptor implementując klasę \textit{AuthTokenInterceptor}, którego rolą było dodanie do każdego zapytania nagłówka (ang. header) z lokalnie zapisanym tokenem identyfikującym użytkownika. Interceptor aplikacji jest wywoływany zawsze i tylko jeden raz, nie wpływają na to przekierowania ani ponawianie zapytań. Aby zintegrować interfejs używanego klienta z interceptorem, należało dodać dodatkowego klienta - \textit{OkHttpClient}\cite{OkHttpClient}. Pochodzi z biblioteki OkHTTP, którą można było wykorzystać do komunikacji aplikacji mobilnej z serwerem, jednak postawiono wybrać Retrofit 2 z uwagi na mniejszy poziom skomplikowania oferowanego API.

\par Rezultatem każdego zapytania jest struktura \textit{Single<Response<T> >}, gdzie T jest oczekiwanym typem zwracanego obiektu. Obiekt \textit{Single} informuje o tym, że jest spodziewana pojedyncza odpowiedź. \textit{Response} jest strukturą zdefiniowaną w projekcie inżynierskim. Zawiera kod odpowiedzi opisywany szerzej przy sposobie implementacji błędów, a także także pole \textit{data} z przesłanymi przez serwer danymi.


\section{Logika rejestracji i logowania (Anna Malizjusz)}
\par Rejestracja użytkownika polega na podaniu trzech informacji: adresu email oraz dwukrotnym podaniu hasła. Każde z tych pól jest walidowane. Adres email powinien mieć formę xxx@yyy.zzz, gdzie xxx, yyy i zzz są dowolnymi ciągami znaków. Hasło nie powinno być trywialne. Musi zawierać co najmniej jedną cyfrę, jedną wielką i jedną małą literę, a także mieć przynajmniej 8 znaków długości. Poprawność walidacji została sprawdzona testami jednostkowymi.

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{registerUnitTestResult}
\caption{Testy jednostkowe sprawdzające poprawność sposobu walidacji formularza rejestracji}
\label{fig:tokenPayload}
\end{figure}


\section{Wyszukiwanie atrakcji turystycznych i zakwaterowania (Anna Malizjusz)}
\par Dodanie konkretnego miejsca do planu dnia jest możliwe po jego wyszukaniu. W tym celu stworzono ekran umożliwiający wybranie obiektu z mapy. Na wyświetlanym obszarze są widoczne pinezki odpowiadające obiektom w podanej okolicy.

\par Głównym komponentem widoku wyszukiwania jest \textit{SearchView}\cite{SearchView}. Dzięki temu na ekranie widać pole, w które można wpisać nazwę lub początek nazwy miasta i wybrać je z listy. Mapa automatycznie przeniesie się do wskazanego miejsca. Implementacja mechanizmu podpowiedzi znajduje się w klasie \textit{CitySuggestionProvider}, dziedziczącej po \textit{ContentProvider}\cite{ContentProvider}. Kluczowym było nadpisanie metody \textit{query(Uri, String[], Bundle, CancellationSignal)}, która zwracała wynik do widoku. Używając interfejsu komunikacji z serwerem aplikacja pobierała listę proponowanych miast, a \textit{CitySuggestionProvider} zwracał je w formie kursorów.

\par Po wybraniu pinezki jednego z wyświetlanych obiektów na ekranie pojawia się nazwa miejsca, a także możliwość pokazania jego szczegółów. Zostało to osiągnięte dzięki użyciu układowi o nazwie \textit{SlidingUpPanelLayout}\cite{SlidingUpPanelLayout}. Pozwala on na rozwinięcie i późniejsze ukrycie widocznego na dole obszaru ze szczegółowymi informacjami. Te same dane są w późniejszym etapie dostępne po wybraniu elementu z planu dnia. Z tego powodu postanowiono wyodrębnić układ pól z informacjami, zdefiniować go w osobnym pliku i wykorzystać go zarówno w widoku wyszukiwania, jak i widoku detali obiektu.

\par Uwzględniono szczególny przypadek, jakim jest wyszukanie zakwaterowania. Jeżeli aplikacja wykryje, że dany obiekt jest miejscem noclegu, zaproponuje dodatkowo dodanie daty wykwaterowania. Końcowym efektem będzie pojawienie się dwóch elementów w planach dni. Pierwszy z nich jest podpisany jako zakwaterowanie (ang. check in), a drugi jako wykwaterowanie (ang. check out). Wystawienie oceny jest możliwe tylko dla elementu reprezentującego drugie z tych wydarzeń.


\section{Tworzenie planów podróży (Dorota Tomczak)}
\par Tworzenie planów podróży jest kluczową funkcją aplikacji. Stworzenie takiego planu jest możliwe, gdy użytkownik ma przypisaną do swojego konta dowolną podróż. Dodawanie do niej kolejnego elementu planu zostało zrealizowane poprzez prosty formularz, który zawiera:
\begin{itemize}
\item rozwijaną listę z kategoriami miejsc odpowiadającą wybranym kategoriom z \textit{Here API}\cite{Here},
\item pole z nazwą miejsca, które po dotknięciu przekierowuje do ekranu wyszukiwania, a po wybraniu obiektu wypełnia się automatycznie,
\item pola od dnia i od godziny, po których dotknięciu otwierają się dialogi odpowiednio z kalendarzem i zegarem,
\item pola analogiczne do dwóch powyższych, jeśli wybrano kategorię Zakwaterowanie, oznaczające dzień i godzinę wymeldowania,
\item pole z adresem, które wypełnia się automatycznie po wyszukaniu obiektu,
\item pole na notatki, które są potem możliwe do edycji.
\end{itemize}

\par Po zatwierdzeniu formularza zostaje on poddany walidacji – wszystkie pola oprócz notatek muszą być wypełnione, a dla kategorii \textit{Zakwaterowanie} (ang. \textit{Accommodation}) czas zakwaterowania nie może być przed czasem wykwaterowania. Jeśli formularz pomyślnie przejdzie próbę walidacji, nowy element planu podróży zostaje utworzony.
Elementy planu dnia wyświetlają się w formie chronologicznej listy rozdzielonej separatorami z datami. Do implementacji tego rozwiązania posłużył adapter, który na podstawie typu elementu określa jaki układ xml (ang. layout xml) wyświetlić – czy ten dla elementu planu czy daty. Aby oba typy mogły być używane przez adapter, muszą dziedziczyć po wspólnym interfejsie, którym jest \textit{DayPlanItem} z jedną metodą, która zwraca typ obiektu.
\par Jednak zanim nowy element planu dnia może zostać przekazany do adaptera i wyświetlony na ekranie jest najpierw dodawany do kolekcji typu \textit{TreeSet}, która sortuje znajdujące się w niej elementy po wyniku zwracanym przez metodę \textit{compareTo(other: PlanElement): Int}, zaimplementowaną w klasie dodawanych elementów. Następnie tworzona jest lista składająca się z separatorów oraz wspomnianych elementów – po sprawdzeniu pola \textit{fromDate} elementu, następuje decyzja, czy rozdzielić elementy nowym separatorem z dniem czy nie. Tak przygotowana lista trafia do adaptera i efektem jest widok posortowanych chronologicznie elementów planów dni w podróży.


\section{Implementacja skanowania dokumentów z użyciem OpenCV (Dorota Tomczak)}
\par Aplikacja umożliwia zrobienie zdjęcia, wybranie czworokątnego obszaru oraz takie przycięcie i modyfikację kolorów fotografii aby uzyskać efekt skanu. W początkowych założeniach zakładano skorzystanie z gotowej biblioteki, która poza wymienionymi wyżej funkcjonalnościami dokonywałaby automatycznej detekcji krawędzi, jednak ze względu na brak darmowych i dostosowanych do potrzeb rozwiązań zdecydowano stworzyć skaner od podstaw bazując na projekcie open-source \textit{SimpleDocumentScanner-Android}\cite{SimpleDocumentScanner-Android}.

\par Wykonanie fotografii jest możliwe jeśli użytkownik nadał aplikacji odpowiednie uprawnienia. Są one weryfikowane przy każdej próbie dodania skanu. Jeśli aplikacja została do tego uprawniona, tworzony jest plik tymczasowy w pamięci urządzenia, a następnie otwierany jest widok kamery za pomocą intencji (ang. intent) utworzonej poprzez podanie do konstruktora nazwy odpowiedniej akcji. Zdjęcie wykonane przez użytkownika jest zapisywane w utworzonym wcześniej pliku tymczasowym a jego ścieżka przekazywana do aktywności (ang. activity) skanera, aby umożliwić w niej jego wyświetlenie i modyfikację.

\par W celu zaimplementowania możliwości wyboru obszaru zdjęcia poprzez gesty użytkownika dodano specjalną klasę dziedziczącą po \textit{ImageView}. Taka klasa mogła zostać następnie dodana do layoutu xml skanera, a zaimplementowane w niej metody pozwoliły na rysowanie i przeciąganie czterech linii złączonych końcami i tworzących czworokąt. Końce czworokątu są reprezentowane przez cztery zmienne typu \textit{PointF} zawierające informacje o ich położeniu na ekranie urządzenia. Po każdym wykryciu gestu przeciągnięcia linii łączącej punkty, obliczane jest ich nowe położenie, a następnie ponownie złączane są linią. Gdy użytkownik zatwierdzi zaznaczony obszar punkty transformowane są z ich współrzędnych na urządzeniu na współrzędne na zdjęciu.

\par Kolejnym etapem jest uzyskanie efektu zeskanowanego dokumentu. Aby móc to osiągnąć zastosowano bibliotekę \textit{OpenCV}\cite{OpenCV}, której pliki źródłowe musiały zostać dołączone do projektu aplikacji w postaci modułu. Aby ograniczyć rozmiar aplikacji wynikowej, który znacznie wzrósł po dodaniu biblioteki, usunięto jej klasy, które nie były potrzebne do realizacji funkcjonalności. Najważniejszymi operacjami, które dostarczyła OpenCV jest transformacja perspektywiczna (ang. perspective transform), która w ogólności zajmuje się przekształceniem trójwymiarowego świata do dwuwymiarowego obrazka, oraz progowanie obrazu (ang. thresholding), czyli metoda segmentacji obrazu, pozwalająca uzyskać obraz binarny z obrazu kolorowego. Otrzymany skan po zastosowaniu tych dwóch operacji i innych pomocniczych może być przez użytkownika zachowany lub odrzucony. W tym pierwszym przypadku zostaje on przesłany na serwer.

\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{scan1}
\caption{Zaznaczanie obszaru do skanowania.}
\label{fig:scan1}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{scan2}
\caption{Skan wynikowy po transformacjach zdjęcia.}
\label{fig:scan2}
\end{subfigure}
\caption{Skanowane biletu.}
\label{fig:Eimage}
\end{figure}

\section{Obsługa przesyłania i pobierania plików (Dorota Tomczak)}
\par Aby umożliwić użytkownikom korzystanie ze swoich kont na różnych urządzeniach oraz udostępnianie stworzonych przez siebie podróży, wynikła konieczność przesyłania dodanych zdjęć na serwer, zamiast przechowywania ich lokalnie na urządzeniach mobilnych. Zdjęciami w aplikacji mogą być wykonane skany lub fotografie dodane do poszczególnych podróży, a ich przesyłanie odbywa się przy pomocy RESTowego API udostępnianego przez serwer, jak zostało to opisane w podrozdziale 5.2. Zapytania za to odpowiadające są dodatkowo opatrzone adnotacją \textit{@Multipart}, aby umożliwić przesyłanie całych plików w ciele (ang. body) żądania, natomiast pliki przekształcane są na typ \textit{MultiPartBody.Part}. Gdy plik zostanie odebrany po stronie serwera następuje próba jego zapisu w ustawionym w konfiguracji folderze przez \textit{FileStorageService}, czyli serwis do przechowywania plików. Następnie ścieżka do pliku jest dodawana do bazy wraz z innymi niezbędnymi informacjami umożliwiającymi jego identyfikację.

\par Ładowanie plików w aplikacji zostało zrealizowane dzięki bibliotece \textit{Glide}\cite{Glide}, która pozwala na zwiększenie efektywności tego procesu poprzez automatyczne cachowanie i optymalizację rozmiaru zdjęcia. Znając adres, pod którym znajduje się plik, użycie wspomnianej biblioteki jest bardzo proste, dlatego na większą uwagę zasługuje proces wysyłania fotografii przez serwer. Plik o wskazanej nazwie zostaje załadowany jako typ \textit{Resource} przez \textit{FileStorageService}, a następnie konstruowana jest odpowiedź serwera, która w ciele zawiera otrzymany zasób. Odpowiedź jest dodatkowo opatrzona nagłówkiem \textit{Content-Disposition}, który zawiera informację o tym, że plik ma zostać potraktowany jako załącznik. 


\chapter{Serwer REST}
\section{Implementacja serwera (Anna Malizjusz)}
\par Serwer dla aplikacji mobilnej został zaimplementowany w języku Kotlin. Celem było stworzenie bezstanowego API zgodnego z tzw. RESTful Web Service. Oznacza to, że na serwerze nie jest utrzymywana sesja użykownika, a każde zapytanie jest niezależne od poprzednich. Każdorazowo należy podać wszystkie niezbędne informacje niezbędne do realizacji żądania, m. in. token, który potwierdza tożsamość użytkownika i uprawnia go do określonych akcji.
\par Wykorzystano framework Spring Boot\cite{Spring documentation}. Jest on oparty na platformie Spring, która dostarcza mechanizmów wstrzykiwania zależności, możliwości użycia wzorca MVC (ang. model-view-controller), a także modułów do implementacji testów jednostkowych. Celem obu frameworków jest ułatwienie implementacji serwera. Jedną z zalet użytego niniejszej pracy frameworka jest prosta konfiguracja, która nie wymaga tworzenia plików w formacie xml. Wynika to z zastosowania reguły \textit{konwencja ponad konfigurację} (ang. convention over configuration). Programista nie musi definiować wszystkich ustawień, jeśli stosuje się do przyjętych konwencji. W przypadku technologii Spring Boot kluczowe są adnotacje nad klasami pełniącymi określone role. 
Konfiguracja serwera zachodzi automatycznie na podstawie zależności, jeśli dodano adnotację "@EnableAutoConfiguration" do klasy uruchamiającej serwer. Framework dostarcza również narzędzi do tworzenia punktów końcowych (ang. endpoints).

\par Skorzystano z mechanizmu wstrzykiwania zależności. Klasy mogą być oznaczone jako komponenty (@Component), serwisy (@Service). Serwis jest szczególnym typem komponentu. Komponenty są zarządzalnymi obiektami w aplikacji oraz mogą być wstrzykiwane do pól odpowiedniego typu, które są oznaczone adnotacją @Autowired. Serwisy to elementy, które należą do logiki biznesowej.
 
\par Definicję punktów końcowych umieszczono w klasach kontrolerów oznaczonych adnotacją "@RestController". Zdefiniowano kilka rodzajów kontrolerów, aby rozdzielić odpowiedzialność za poszczególne zadania:
\begin{itemize}
\item kontroler użytkowników jako \textit{ServerUserController}
\item kontroler podróży jako \textit{ServerTravelController}
\item kontroler odpowiedzialny za skany jako \textit{ServerScanController}
\item kontroler pośredniczący w komunikacji z zewnętrznym API dostarczanym przez firmy Google oraz Here: \textit{ServerHereGoogleApiController}
\item kontroler funkcji rekomendujących: \textit{ServerRecommendationController}
\end{itemize}

\par W każdym z kontrolerów wyróżniono punkty końcowe (ang. endpoints). Zastosowano powszechną konwencję nazewnictwa oraz znaczenie czasowników protokołu HTTP. Przykładowo dodawanie (POST), usuwanie (DELETE), aktualizacja (PUT) oraz odczytanie (GET) podróży obsługiwane w kontrolerze \textit{ServerTravelController} odbywa się w następujący sposób:
\begin{itemize}
\item \textit{@GetMapping("users/{userId}/travels")} zwraca podróże należące do użytkownika o podanym numerze ID;
\item \textit{@PostMapping("users/{userId}/travels")} dodaje podróż podaną w ciele zapytania (ang. body) do podróży użytkownika o podanym numerze ID;
\item \textit{@PutMapping("users/{userId}/travels")} aktualizuje podróże zawarte w ciele zapytania (ang. body);
\item \textit{@DeleteMapping("users/{userId}/travels")} umożliwia usunięcie listy podróży, która została wysłana w ciele zapytania.
\end{itemize}

\par Każde zapytanie powinno zawierać w nagłówku token użytkownika, który jest sprawdzany w celu weryfikacji źródła zapytania. Parametry ścieżki (ang. path parameters) punktów końcowych uszczegóławiają zasób, np. "userId" w powyższym przykładzie. Dodatkowe parametry zapytania (ang. query parameters) i ciało zapytania(ang. body)  pozwala na sprecyzowanie żądania.

\section{Obsługa sytuacji wyjątkowych (Dorota Tomczak)}
\par Aplikacja mobilna komunikuje się z serwerem poprzez REST'owe API, jeśli więc po stronie serwera dojdzie do sytuacji wyjątkowej, aplikacja powinna otrzymać wiadomość o tym, co poszło nie tak i odpowiednio ją obsłużyć. W tym celu zdefiniowano kilkanaście własnych wyjątków, czyli klas dziedziczących po klasie java.lang.Exception oraz implementujących własny interfejs ApiException, który zawiera kod błędu wraz z wiadomością opisującą błąd. W celu uniknięcia tworzenia wielu bloków try-catch oraz powielania bloków kodu zaimplementowano globalny moduł obsługi wyjątków, czyli klasę opatrzoną adnotacją \textit{@RestControllerAdvice}, zawierającą dwie metody z adnotacjami \textit{@ExceptionHandler} – jedna służąca do obsługi nowo zdefiniowanych wyjątków, a druga do pozostałych. W obu tych metodach złapany wyjątek jest dodawany do logów serwera, a następnie zwracana jest odpowiedź z odpowiednim kodem błędu. Tak zdefiniowany moduł pozwala na obsługę wszystkich wyjątków występujących na serwerze po dowolnym żądaniu obsłużonym przez każdy z kontrolerów.

\section{Uwierzytelnienie i autoryzacja użytkownika (Anna Malizjusz)}
\par Podstawowy mechanizm uwierzytelnienia i autoryzacji opiera się na standardzie opisanym po raz pierwszy w 2010 roku jako JSON Web Token. Jest on "kompaktowym i bezpiecznym sposobem przesyłania informacji między dwiema stronami" (RFC 7519\cite{JWT}). Użyto biblioteki \textit{io.jsonwebtoken.jjwt}\cite{JWT library}, która dostarcza interfejs do generowania i odczytywania tokenów w przystępny sposób.

\par Uwierzytelnienie użytkownika odbywa się podczas logowania. Serwer porównuje podany adres email oraz zmodyfikowane funkcją mieszającą hasło z danymi zapisanymi w bazie danych. Jeżeli informacje są zgodne, na ich podstawie jest generowany token. JWT pozwala na dodanie twierdzeń (ang. claims) i ustawienie czasu ważności, które zostaną zaszyfrowane przy pomocy algorytmu HS256 i sekretnego klucza. Używane są następujące twierdzenia określające podane cechy tokenu:
\begin{itemize}
\item \textit{iss} - wydawca tokenu (ang. issuer),
\item \textit{sub} - podmiot (ang. subject),
\item \textit{email} - adres email użytkownika,
\item \textit{id} - id użytkownika,
\item \textit{generatedTimestamp} - czas wygenerowania tokenu.
\end{itemize}
\par Przykładowy token zapisany składający się z 3 części XXX.YYY.ZZZ zaprezentowano poniżej:\\eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJBY2Nlc3NUb2tlbiIsImdlbmVyYXRlZFRpbWVzdGFtcCI6eyJ5Z\\WFyIjoyMDE5LCJtb250aCI6Ik5PVkVNQkVSIiwibW9udGhWYWx1ZSI6MTEsImRheU9mTW9udG\\
giOjE3LCJjaHJvbm9sb2d5Ijp7ImlkIjoiSVNPIiwiY2FsZW5kYXJUeXBlIjoiaXNvODYwMSJ9LCJkYXl\\
PZldlZWsiOiJTVU5EQVkiLCJsZWFwWWVhciI6ZmFsc2UsImRheU9mWWVhciI6MzIxLCJlcmEiOi\\
JDRSJ9LCJpc3MiOiJUcmF2ZWxBcHBfU2VydmVyIiwiaWQiOjEwLCJleHAiOjE1NzQxMDc4NTksI\\mVtYWlsIjoicXFxMSJ9.vs9PVbgkzxsLpRqxXY0Jaey6fmMXdOLwQW\_dUe9Xxcw

\par Pierwsza część to zakodowany nagłówek, który zawiera algorytm szyfrujący oraz typ tokenu. 
Kolejna jest zawartość, którą tworzą określone przy generacji tokenu twierdzenia. Ostatnia część to podpis. Użyto w nim znanego tylko serwerowi sekretnego klucza, niezbędnego do odszyfrowania otrzymanego od klienta tokenu.
\par Użytkownik aplikacji mobilnej przechowuje swój token i każdorazowo dołącza go do wysyłanych zapytań. Aplikacja serwerowa przy użyciu klucza odczytuje go i weryfikuje otrzymane dane, w szczególności datę ważności tokenu oraz id użytkownika.

\par Rozszyfrowany token jest zapisywany w formacie JSON w postaci, która jest czytelna i zrozumiała dla człowieka. Dzięki użytej bibliotece \textit{io.jsonwebtoken.jjwt} z tokenu w formacie JSON można odczytywać dane jak ze słownika, np.
\textit{Jwts.parser().setSigningKey(SECRET\_KEY).parseClaimsJws(token).body["id"].toString()}, aby odczytać wartość twierdzenia o nazwie "id".

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{tokenPayload}
\caption{Rozszyfrowana zawartość podanego powyżej tokenu.}
\label{fig:tokenPayload}
\end{figure}


\section{Komunikacja z zewnętrznym API (Anna Malizjusz)}
\par Potrzeba wyszukiwania infromacji o miejscach na świecie wymusiła korzystanie z zewnętrznych dostawców danych. Po analizie przeprowadzonej na etapie tworzenia specyfikacji wymagań systemowych zdecydowano o użyciu Here API\cite{HereApi}. Próba implementacji rozwiązania zmusiła programistów do skorzystania zarówno z wybranego dostawcy, jak i z początkowo odrzuconego Google API\cite{GoogleApi}, które oferowało dużo bogatszą bazę sposobów transportu.

\par Podstawowym problemem było odczytanie danych. Wynikiem wysłania zapytania do dostawcy informacji był ciąg znaków zawierający znaczą ilość danych nie tylko o temacie zapytania. W przypadku każdego typu żądania przeanalizowano wynik i zdefiniowane wspólną metodę wyszukującą oraz wybierającą niezbędne informacje. Następnie należało je dopasować do potrzeb - nie wszystkie informacje były potrzebne aplikacji. Napisano funkcję zmieniającą ciąg znaków na instancję klasy. Skorzystano z możliwości klasy \textit{JsonParser}\cite{JsonParser} oraz \textit{GsonBuilder}\cite{GsonBuilder}.

\par Należało też uwzględnić sposób zapisanych informacji. Wiele znaków, np. "'" było zakodowanych, aby uniemożliwić wstrzykiwanie złośliwyego kodu. W celu rozwiązania tego problemu skorzystano z funkcji \textit{StringEscapeUtils.unescapeHtml3()}\cite{escapeUtils}, która zmieniła formę znaków z kodowej na graficzną.

\section{Wspólne klasy serwera i aplikacji}
\par Podczas implementacji napotkano problem klas powtarzających się w identycznej formie po stronie aplikacji i serwera. Stwarzało to kłopot przy edycji - obie wersje pliku musiały być zawsze identyczne. Spróbowano rozwiązać to w następujące sposoby.

\subsection{Oddzielny projekt dodany jako moduł (Dorota Tomczak)}

\subsection{Submoduły w repozytorium (Anna Malizjusz)}
\par Podjęto próbę dodania repozytorium zawierającego tylko wspólne pliki, a następnie wstawienia go do głównego repozytorium jako submoduły. Stworzyło to kolejne problemy w postaci konieczności częstych aktualizacji submodułów.
\par Zrezygnowano z submodułów i wykorzystano symboliczne powiązania.
Git traktował powiązany folder jako istniejący, więc nie powodowało to dodatkowych problemów. Plik zmieniony i zapisany w jednej z lokalizacji był automatycznie odwzorowywany w drugiej. Rozwiązanie to, choć z pozoru skuteczne nie mogło być wykorzystane przez wszystkich członków zespołu ze względu na różnice w systemie operacyjnym. Używane były zarówno komputery z system Window, oparte na Linuxie oraz MacOS. Ostatecznie próby rozwiązania zarzucono.


\section{Rekomendacja miejsc z wykorzystaniem Collaborative Filtering (Dorota Tomczak)}
\par Po dodaniu elementu planu podróży można wejść w jego szczegóły i dokonać oceny miejsca, które znajduje się w planie. Oceny miejsc w skali od jednego do pięciu są przechowywane wraz z użytkownikami, którzy wystawili daną ocenę w osobnej tabeli bazy danych. Na podstawie tych ocen mogą być następnie obliczane rekomendacje przy użyciu techniki zwanej \textit{Collaborative-Filtering}, a w szczególności jej odmianą opartą na użytkowniku (ang. user-based).
\par Do implementacji wspomnianej metody wyznaczania poleceń wykorzystano bibliotekę \textit{Apache Mahout}\cite{Apache Mahout}, która oferuje wiele implementacji algorytmów opartych o uczenie maszynowe. Po wskazaniu źródła danych, czyli w tym przypadku tabeli w bazie, utworzono model danych, który posłużył do wykonania niezbędnych obliczeń. Wyznaczenie polecanych miejsc przebiega w następujący sposób: wyliczane jest podobieństwo między użytkownikami algorytmem współczynnika korelacji Pearsona, algorytm k – najbliższych sąsiadów dla k równego 2 wyznacza najbardziej polecane miejsca, a na koniec na podstawie otrzymanych wyników tworzony jest obiekt klasy \textit{GenericUserBasedRecommender}. Wywołanie metody \textit{recommend} na obiekcie z podanym identyfikatorem użytkownika i liczbą rekomendacji, które ma zwrócić, skutkuje otrzymaniem listy identyfikatorów polecanych miejsc, jeśli zostały jakieś znalezione.
\par Testy przedstawionego rozwiązania aplikacją \textit{Postman}\cite{Postman} wykazały, że zwrócenie odpowiedzi trwa bardzo długo (nawet 20 s), a im większa liczba danych w bazie tym czas oczekiwania się wydłużał. Aby uniknąć konieczności oczekiwania na wynik po stronie aplikacji mobilnej, zdecydowano na prezentację polecanych miejsc w postaci powiadomień, czyli w momencie gdy serwer jest gotowy na wysłanie rekomendacji wysyła odpowiednie powiadomienie, a do tego czasu użytkownik może dalej swobodnie nawigować po aplikacji.
\par W celu wysyłania powiadomień od serwera do aplikacji mobilnej skorzystano z usługi \textit{Firebase Cloud Messaging}\cite{Firebase}. Serwer po obliczeniu polecanych miejsc buduje wiadomość w postaci mapy, która ma zostać wysłana na urządzenie o określonym unikalnym tokenie. Za wysłanie odpowiada instancja klasy \textit{FirebaseMessaging}. W konsoli usługi można zobaczyć statystyki wysłanych wiadomości, które zawierają między innymi informacje o tym ile z nich zostało otwartych przez użytkowników. Do odbierania wiadomości po stronie aplikacji mobilnej zaimplementowano serwis, który dzięki temu, że dziedziczy po \textit{FirebaseMessagingService} może reagować na zdarzenia takie jak nadejście wiadomości oraz zmiana tokena.
\par Gdy serwis odbierze wiadomość, odczytuje ją, a następnie tworzy powiadomienie, ustawiając jego parametry takie jak m.in. jego tytuł, priorytet, dźwięk. Powiadomienie jest następnie obsługiwane przez \textit{NotificationManager} i wyświetla się na ekranie urządzenia mobilnego. Użytkownik może powiadomienie od razu usunąć lub otworzyć. W drugim przypadku zostaje on przekierowany do aplikacji mobilnej, gdzie zostaje mu zaprezentowana lista polecanych miejsc wraz z nazwą i adresem.


\chapter{Placeholder - baza danych}

\chapter{Testy}

\section{Testy jednostkowe i instrumentalne aplikacji mobilnej (Dorota Tomczak)}
\par Dla aplikacji mobilnej napisano 23 testy jednostkowe oraz 9 instrumentalnych, które obejmują klasy i metody komponentów służących do logowania, rejestracji oraz przekierowania po starcie aplikacji. Testy jednostkowe, czyli takie które weryfikują poprawność realizacji pojedynczych funkcjonalności aplikacji, zostały zbudowane w oparciu o następujące zależności: \textit{JUnit 4}\cite{JUnit}, \textit{JUnitParams}\cite{JUnitParms} do tworzenia testów parametryzowanych oraz bibliotekę \textit{MockK}\cite{MockK} służącą do mockowania obiektów w języku Kotlin. Testy te służą do weryfikacji działania metod zdefiniowanych w prezenterach, z tego względu przed startem każdego z nich odpowiedni prezenter nie jest mockowany, ale inicjalizowany w sposób, który umożliwia jego „szpiegowanie”. Aby zasymulować asynchroniczną komunikację sieciową pomiędzy aplikacją a serwerem, która odbywa się poprzez zastosowanie biblioteki \textit{RxJava}\cite{RxJava}, stworzono klasę pomocniczą \textit{RxImmediateJavaSchedulerRule}, która ustawia wszystkie metody, rozpoczynające nowe wątki, aby korzystały zamiast tego z wątku obecnego.
\par Testy instrumentalne, czyli takie które działają na emulatorze lub na fizycznym urządzeniu mobilnym, zostały zrealizowane dla dwóch aktywności – \textit{SignInActivity} oraz \textit{SignUpActivity} i testują, czy na ekranie wyświetlają się prawidłowe informacje, czy akcje użytkownika wywołują odpowiednie metody oraz czy aplikacja reaguje na nie w odpowiedni sposób. Wykorzystują wiele zależności, w tym między innymi \textit{Espresso}\cite{Espresso} i \textit{MockK-Android}\cite{MockK-Android}. W klasach testowych tworzone są role aktywności (\textit{activityScenarioRole}), na których następnie można wywoływać określone akcje np. wciśnięcie przycisku, czy wpisanie tekstu w polu do tego przeznaczonym. 
\par Wszystkie testy, zarówno instrumentalne jak i jednostkowe zostały podzielone na trzy segmenty:
\begin{itemize}
\item \textit{given} -  definicja danych wejściowych oraz mockowanie wywołań metod i obiektów,
\item \textit{when} - wywołanie testowanej metody lub wykonanie akcji,
\item \textit{then} - weryfikacja otrzymanych rezultatów po wywołaniu metody lub wykonaniu akcji.
\end{itemize}
Do nazewnictwa testów przyjęto następującą konwencję: co powinno się stać, gdy zostaną spełnione określone warunki. Przykładowo "Should display snackBar with info message when given password in SignUp is incorrect", co w tłumaczeniu oznacza "Powinien się wyświetlić snackBar z komunikatem informacyjnym, gdy hasło podane w SignUp jest nieprawidłowe".

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{instrumentationTest}
\caption{Przykładowy test instrumentalny.}
\label{fig:instrumentationTest}
\end{figure}


\chapter{Placeholder - Podręcznik użytkownika}

\chapter{Podsumowanie}

\chapter*{Podział zadań implementacyjnych}
\addcontentsline{toc}{chapter}{Podział zadań implementacyjnych}

\captionof{table}{Autorzy zaimplementowanych funkcji\label{tab:autorzy}}

\centering
\begin{longtable}{ |p{3.3cm}|p{3.3cm}|p{3.3cm}|p{3.3cm}| }
\hline
\thead{Dorota Tomczak} & \thead{Magdalena Solecka} & \thead{Anna Malizjusz} & \thead{Karolina Makuch}\\

\hline
Zaprojektowanie i implementacja bazowej aplikacji mobilnej (wzorzec MVP, wstrzykiwanie zależności Dagger2)
& Wybór systemu zarządzania bazą danych Postgresql
& Projekt i implementacja bazowej postaci serwera oparta o framework Spring Boot 
& Implementacja wyświetlania znajomych oraz wyszukiwania użytkowników w celu dodania ich do znajomych \\

\hline
Obsługa sytuacji wyjątkowych na serwerze
& Implementacja podstawowego dostępu do bazy wyznaczającego schemat dla kolejnych modeli przy użyciu repository pattern
& Implementacja mechanizmów uwierzytelniania i autoryzacji na serwerze
& Implementacja manualnej realizacji planu \\

\hline
Implementacja skanera z użyciem OpenCV
& Pierwsza implementacja ekranu logowania i rejestracji
& Wyszukiwanie obiektów w aplikacji - implementacja wyboru miejsca z mapy
& Implementacja udostępniania planu podróży wybranym znajomym\\

\hline
Tworzenie planów podróży po stronie aplikacji (formularz dodawania i chronologiczne wyświetlanie listy)
& Dodawanie planów podróży po stronie serwera
& Wyświetlanie szczegółowych informacji o miejscu w planie dnia
& Implementacja udostępniania planu dnia w medium społecznościowym (Facebook)\\

\hline
Obsługa pobierania i przesyłania plików (skany i zdjęcia podróży)
& Implementacja testów automatycznych operacji dostępu do bazy danych
& Odczytywanie i korzystanie z informacji otrzymanych z Here API i Google API
& \\

\hline
Integracja w aplikacji komponentu \textit{Navigation drawer }
& Implementacja trybu usuwania w aplikacji mobilnej
& Komunikacja z serwerem w aplikacji mobilnej
& \\

\hline
Implementacja rekomendacji miejsc i wysyłanie ich w formie powiadomień
& Implementacja dodawania podróży oraz zmiany nazwy podróży
& Implementacja logiki rejestracji i logowania w aplikacji
& \\

\hline
Testy jednostkowe i instrumentalne dla logowania, rejestracji i komponentu \textit{launcher}
& 
& 
& \\

\hline
\end{longtable}


\bibliographystyle{plain}
\begin{thebibliography}{1}
\addcontentsline{toc}{chapter}{Bibliografia}
  \bibitem{Here} developer.here.com
  \bibitem{gms.location} developers.google.com/android/reference/com/google/android/gms/location/package-summary
  \bibitem{Android usage} gs.statcounter.com/android-version-market-share/mobile-tablet/worldwide
  \bibitem{SearchView} https://developer.android.com/reference/android/widget/SearchView
  \bibitem{ContentProvider} https://developer.android.com/reference/android/content/ContentProvider
  \bibitem{SlidingUpPanelLayout} https://github.com/umano/AndroidSlidingUpPanel
  \bibitem{Spring documentation} https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/
  \bibitem{JWT} https://tools.ietf.org/html/rfc7519
  \bibitem{JWT library} https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt
  \bibitem{Retrofit library} https://square.github.io/retrofit/
  \bibitem{OkHttpClient} https://square.github.io/okhttp/
  \bibitem{Dagger 2} https://github.com/google/dagger
  \bibitem{SimpleDocumentScanner-Android} https://github.com/jbttn/SimpleDocumentScanner-Android
  \bibitem{OpenCV} https://opencv.org/
  \bibitem{Glide} https://bumptech.github.io/glide/
  \bibitem{Apache Mahout} https://mahout.apache.org/
  \bibitem{Postman} https://www.getpostman.com/
  \bibitem{Firebase} https://firebase.google.com/docs/cloud-messaging
  \bibitem{HereApi} https://developer.here.com/
  \bibitem{GoogleApi} https://cloud.google.com/maps-platform/routes/
  \bibitem{JsonParser} https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/JsonParser.html
  \bibitem{GsonBuilder} https://static.javadoc.io/com.google.code.gson/gson/2.8.0/com/google/gson/GsonBuilder.html
  \bibitem{escapeUtils} https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringEscapeUtils.html
  \bibitem{JUnit} https://junit.org/junit4/
  \bibitem{JUnitParams} https://github.com/Pragmatists/JUnitParams
  \bibitem{MockK} https://mockk.io/
  \bibitem{RxJava} https://github.com/ReactiveX/RxJava
  \bibitem{Espresso} https://developer.android.com/training/testing/espresso
  \bibitem{MockK-Android} https://mockk.io/ANDROID.html
\end{thebibliography}


\listoffigures
\listoftables

\end{document}
