\documentclass[10pt,twoside,a4paper]{report}

\usepackage{polski}
\usepackage{indentfirst}
\usepackage{sectsty}
\usepackage{helvet}
\usepackage{caption}
\usepackage{multirow}
\usepackage{makecell}
\usepackage{array}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage[section]{placeins}
\usepackage{enumitem}% http://ctan.org/pkg/enumitem
\setlist[itemize]{noitemsep, topsep=0pt}
\setlist[enumerate]{noitemsep, topsep=0pt}

\graphicspath{ {./images/} }

\chapternumberfont{\Large}
\chaptertitlefont{\huge}

\usepackage[font={normalsize,it}]{caption}

\linespread{1.5}
\usepackage[table]{xcolor}
\usepackage{fourier} 
\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}

\usepackage[a4paper, bindingoffset=1cm, margin=2.5cm]{geometry}
\widowpenalty10000
\clubpenalty10000

%--------------------------------------------------------------------
% Numeracja stron 
%--------------------------------------------------------------------

\pagenumbering{arabic}

\RequirePackage{fancyhdr}

\fancypagestyle{plain}{
  \fancyhf{}
  \fancyfoot[C]{\fontsize{9pt}{9pt}\selectfont\thepage}%
   \renewcommand{\headrulewidth}{0.0pt}
}

\pagestyle{plain}

\begin{document}
\chapter*{Pusta strona 1}
\chapter*{Pusta strona 2}
%dodanie nienumerowanych rozdziałów do spisu treści
\addcontentsline{toc}{chapter}{Streszczenie}
\addcontentsline{toc}{chapter}{Wykaz najważniejszych oznaczeń i skrótów}
\renewcommand{\familydefault}{\sfdefault}
\chapter*{Streszczenie}
(maksymalnie 1 strona)\par
(strona nr 3 – numer widoczny)\par
Xxxxxxxx xxxxxxx xxxxxxxx xxxxxxxxxxxx xxxxxxxx x xxxxxxxxx. Xxxxx xxxxxxxxx xxxx xxxxxx xxxxx. Xxxxxxxx xxxxxxx xxxxxxxx xxxxxxxxxxxx xxxxxxxx x xxxxxxxxx. Xxxxxxxx xxxxxxx xxxxxxxx xxxxxxxxxxxx xxxxxxxx x xxxxxxxxx. 
\newline\textbf{Słowa kluczowe}: xxxxxxx, xxxxxxxx
\newline\textbf{Dziedzina nauki i techniki, zgodnie z wymogami OECD}: 
dziedzina, technika, …
\newline ABSTRACT (maksymalnie 1 strona)
\par Xxxxxxxx xxxxxxx xxxxxxxx xxxxxxxxxxxx xxxxxxxx x xxxxxxxxx. Xxxxx xxxxxxxxx xxxx xxxxxx xxxxx. Xxxxxxxx xxxxxxx xxxxxxxx xxxxxxxxxxxx xxxxxxxx x xxxxxxxxx. Xxxxxxxx xxxxxxx xxxxxxxx xxxxxxxxxxxx xxxxxxxx x xxxxxxxxx.
\newline\textbf{Keywords}: xxxxxxx, xxxxxxxx

\tableofcontents
\chapter*{Wykaz najważniejszych oznaczeń i skrótów}
\noindent REST - Representational State Transfer\\
JSON - JavaScript Object Notation\\
JWT - JSON Web Token\\
API - Application Programming Interface\\
MVP - Model View Presenter\\


\chapter{Wstęp i cel pracy}  
xxxxx
\chapter{Przegląd podobnych rozwiązań} 
Aplikacje do planowania podróży to często spotykane rozwiązanie ułatwiające organizowanie wyjazdów. Oferowane są dla systemów operacyjnych Android oraz iOS odpowiednio w serwisach Google Play i Apple Store. Przetestowano 4 przykładowe aplikacje, których podstawowe dane zawiera tabela~\ref{tab:porównianie}.

\begin{table}[ht]
\captionof{table}{Dane testowanych aplikacji\label{tab:porównianie}}
\centering
\begin{tabular}{ |c|c|c|c| }
\hline
\multirow{2}{6em}{\thead{\makecell{Nazwa \\ aplikacji}}} & \multicolumn{2}{c|}{\thead{Google Play}} & \thead{Apple Store}\\
\cline{2-4}
 & Średnia ocena & Ilość pobrań & Średnia ocena \\
\hline
TripIt: Travel Planner & \makecell{4.4/5 \\ (53217 ocen)} & ponad 1 mln & 4.8/5 (122.9K ocen) \\
\hline
Google Trips - Travel Planner & \makecell{4.1/5 \\ (30473 ocen)} & ponad 5 mln & 4.4/5 (3100 ocen) \\
\hline
Sygic Travel: Planuj Podróż & \makecell{4.2/5 \\ (10637 ocen)} & ponad 1 mln & 4.6/5 (1600 ocen) \\
\hline
Expedia & \makecell{4.2/5 \\ (172035 ocen)} & ponad 10 mln & 4.8/5 (551.9K ocen) \\
\hline
\end{tabular}
\end{table}
\section{Aplikacja TripIt: Travel Planner (Dorota Tomczak)}
\par TripIt to aplikacja do planowania podróży, którą przetestowano na urządzeniu z systemem operacyjnym iOS. Dostępna była jedynie w języku angielskim. Podstawowa wersja aplikacji była darmowa, natomiast wersję rozszerzoną (TripIt Pro) oferowano w formie subskrypcji, która kosztowała 49\$ rocznie. Oprócz tego istniała też opcja TripIt for Teams, która pozwalała na planowanie podróży grupy osób.
\par Aby móc korzystać z aplikacji trzeba było najpierw założyć konto w serwisie TripIt, co jednak pozwalało na dostęp do wszystkich swoich planów podróży na różnych urządzeniach. Opcjonalne było natomiast zezwolenie na automatyczne przesyłanie wiadomości e-mail ze swojej skrzynki pocztowej na adres plans@tripit.com. Po umożliwieniu tej opcji, TripIt kilka razy dziennie sprawdzało skrzynkę użytkownika, by następnie pobrać z niej informacje o rezerwacjach lotów, hoteli, samochodów i dodać je do planu podróży.
\par Stworzenie nowego planu podróży było bardzo proste. Wymagało podania miasta docelowego wyjazdu oraz zakresu dat, w których podróż miała się odbyć. Dodatkowo można było dodać ogólną nazwę wyprawy oraz jej opis. Po zalogowaniu do aplikacji na ekranie widoczne były  nadchodzące podróże, a po przełączeniu zakładki również te już odbyte. Obok informacji o nazwie bądź celu podróży, jej terminie i czasu trwania wyświetlało się zdjęcie przedstawiające miasto docelowe podróży, albo zdjęcie samolotu dla miast, których aplikacja zdjęć nie posiadała. Każdą podróż można było usunąć, edytować, scalić z inną oraz dodać do niej plan. 

\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{tripit1}
\caption{Plan podróży.}
\label{fig:TIsubim1}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{tripit2}
\caption{Opcje transportu taksówką.}
\label{fig:TIsubim2}
\end{subfigure}
\caption{TripIt: Travel Planner.}
\label{fig:TIimage1}
\end{figure}

\par Oprócz wspomnianego wcześniej automatycznego dodawania rezerwacji i planów przez aplikację po pobraniu tych informacji ze skrzynki pocztowej, można to też było zrobić manualnie. TripIt oferowało 18 różnych elementów, które można było dodać do planu, między innymi: lot (ang. flight), kwatera (ang. lodging), wynajem samochodu (ang. car rental), teatr (ang. theater), rejs (ang. cruise), transport (ang. transportation) i ogólna aktywność (ang. activity). Poszczególne elementy umożliwiały dodanie różnych informacji o planowanej podróży, jednak każdy z nich wymagał dodania daty i godziny do danej aktywności, aby aplikacja mogła je później zorganizować chronologicznie. Przy wpisywaniu niektórych informacji aplikacja podpowiadała jakie słowa mógł mieć na myśli użytkownik, co bywało pomocne. Było tak na przykład w przypadku wpisywania nazwy linii lotniczych i nazwy restauracji, a także w przypadku wybrania pola przeznaczonego na podanie adresu. Była to usługa dostarczana przez firmę Google. Po wybraniu takiego zasugerowanego słowa TripIt często samodzielnie uzupełniał niektóre informacje, takie jak np. adres strony internetowej danego obiektu, czy godzina odprawy samolotowej.
Po dodaniu nowego elementu do planu podróży można go było edytować, usunąć, przenieść do innego planu lub uzupełnić o szczegóły, które nie były dostępne przy tworzeniu np. informacje o rezerwacji (ang. booking info), zdjęcia (ang. photos), uczestnicy (ang. attendees). Dla każdego elementu dostępny był również nawigator (ang. navigator), który po wybraniu miejsca startowego i docelowego wyszukuje możliwe opcje transportu z szacowanym czasem ich trwania i kosztem (w dolarach). Po wybraniu transportu samochodem lub pieszo, aplikacja TripIt przekierowywała do aplikacji Google Maps, gdzie można było zobaczyć wyznaczoną trasę.

\par Ciekawą funkcją było pozyskiwanie informacji o okolicy (ang. neighborhood info), w której znajdował się dodany obiekt. Usługa ta była dostarczana przez GeoSure i udostępniała wskaźniki między innymi z takich kategorii jak: ogólne bezpieczeństwo (ang. overall safety), ryzyko doznania krzywdy fizycznej (ang. physical harm), ryzyko kradzieży (ang. theft). Poza tym TripIt oferowała też wyświetlenie miejsc, będących w pobliżu obiektu z kilku kategorii: restauracje, kawiarnie, bary, bankomaty, parkingi. Wyszukane miejsca pokazywały się na mapie, a po wybraniu jednego z nich można było między innymi zobaczyć godziny otwarcia oraz dodać je do swojego planu podróży.

\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{tripit3}
\caption{Wyszukanie pobliskich kawiarni.}
\label{fig:TIsubim3}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{tripit4}
\caption{Udostępnianie planu podróży.}
\label{fig:TIsubim4}
\end{subfigure}
\caption{TripIt: Travel Planner.}
\label{fig:TIimage2}
\end{figure}

\par Każdy plan lub element podróży można było udostępnić lub zapisać w formacie txt. Wybierając opcję Invite Others to View Trip, plan podróży wysyłano na wybrany adres mailowy (który może zostać wyszukany poprzez kontakty) osoby, której można nadać jedno z trzech uprawnień: can view, can edit, can edit and is traveling. W tak wysłanej wiadomości znajdował się link do planu podróży wraz z mapą, które można było wyświetlić w przeglądarce lub aplikacji. W przeglądarce wyświetlała się dodatkowo informacja o pogodzie na każdy dzień podróży. Osoby, którym nadano odpowiednie uprawnienia i posiadały one konto w serwisie TripIt, mogły edytować udostępniony im plan podróży.

\par W aplikacji można było przechowywać informacje o swoich dokumentach i kontaktach, które mogły się przydać w razie nieprzewidzianych sytuacji. Dane te były dostępne po wprowadzeniu 4-cyfrowego pinu, który należało uprzednio ustawić. W ustawieniach można było włączyć synchronizację kalendarza na naszym urządzeniu z aplikacją TripIt, co powodowało automatyczne dodawanie informacji o planie podróży z aplikacji do kalendarza. Dodatkowo w aplikacji można było obejrzeć statystyki ze wszystkich swoich podróży, takie jak liczba przebytych kilometrów, liczba odwiedzonych krajów i inne.

\par Opisane wyżej funkcje dotyczyły darmowej wersji aplikacji TripIt. Wersja Pro rozszerzała tą wersję przede wszystkim o rozbudowany system powiadomień oraz mechanizmów śledzących (ang. trackers). Niektóre z tych udogodnień to: powiadomienia o dostępności lepszych miejsc w samolocie, przypomnienia o konieczności odprawy 24 godziny przed wylotem, wyszukiwanie alternatywnych połączeń, wysyłanie informacji o locie w czasie rzeczywistym podczas całej podróży, udostępnianie interaktywnych map lotniska. Wersję TripIt Pro można było przetestować za darmo przez 30 dni.

\par Aplikacja TripIt oferowała wiele możliwości w planowaniu swoich podróży, co pozwalało na stworzenie bardzo szczegółowych planów. Wiele informacji trzeba było wprowadzać samodzielnie, jednak aplikacja często podpowiadała jakie słowa mógł mieć na myśli użytkownik, co znacznie ułatwiało i przyspieszało ten proces. Dodatkowym ułatwieniem była funkcja automatycznego dodawania danych o rezerwacjach, które mogły być pobierane ze skrzynki pocztowej. Dużą zaletą aplikacji była również opcja wyznaczania trasy między dwoma punktami, jednak koszt takiej wyprawy podawany był tylko w dolarach amerykańskich bez względu na kraj, w którym odbywała się podróż i miejsce zamieszkania użytkownika. TripIt pozwalała w łatwy sposób wyszukać sąsiednie obiekty, takie jak restauracje, czy parkingi, jednak brakowało tu atrakcji turystycznych, a odległość od tych obiektów podawana była w stopach (ft) i nie dało się tego zmienić. Z pewnością przydatną funkcją była możliwość udostępnienia stworzonego przez siebie planu innym osobom, jednak by wysłać link ze sformatowanym planem można było to zrobić jedynie na adres mailowy, a nie przez inne środki komunikacji, gdzie wysłany plan był dostępny wyłącznie w formie tekstowej. Wadą aplikacji była jej dostępność jedynie w języku angielskim. Ponadto cena wersji PRO, która wprowadzała szereg dodatkowych udogodnień, była wysoka i mogła odstraszać potencjalnego użytkownika.

\section{Aplikacja Google Trips - Travel Planner (Karolina Makuch)}

\par Aplikacja Google Trips – Travel Planner była dostępna na urządzenia mobilne z systemem iOS oraz Android. Była jedną z popularniejszych aplikacji w Sklepie PLAY. Google Trips była także dostępne w Apple Store. 
\par W celu korzystania z Google Trips należało posiadać konto Google. Umożliwiło to dostęp do planu podróży z różnych urządzeń. Niestety aplikacja miała jeden wariant językowy (język angielski).
\par Na samym początku należało wybrać miasto docelowe. Po wyszukaniu miasta, użytkownik miał możliwość nazwania swojej wycieczki oraz dodawania poszczególnych etapów podróży, uwzględniając przedział czasu poświęcony na każdy z nich.

\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{googletrips1}
\caption{Tworzenie nowej podróży}
\label{fig:GTsubim1}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{googletrips2}
\caption{Przeglądanie mapy z polecanymi obiektami}
\label{fig:GTsubim2}
\end{subfigure}
\caption{Google Trips - Travel Planner.}
\label{fig:GTimage1}
\end{figure}

\par Aplikacja umożliwiała zapisywanie rezerwacji (ang. Reservations) lotu (ang. Flight), hotelu (ang. Hotel), pociągu (ang. Train), autobusu (ang. Bus), samochodu (ang. Car rental) oraz restauracji (ang. Restaurant). W zależności od rodzaju transportu użytkownik uzupełniał odpowiednie informacje takie jak: skąd chce się wybrać, dokąd, kiedy, o której godzinie, numer telefonu, numer potwierdzający,miejsca pasażerów oraz rodzaj transportu. Google Trips posiadał także Notatnik posiadający ograniczenie do 10 000 słów.
\par Kolejną opcją była możliwość przejrzenia oraz zapisania dostępnych atrakcji (ang. Things to do). Zostały one podzielone na kilka podkategorii na przykład : polecane (ang. Top Spots), preferowane (ang. For you), parki (ang. Parks \& gardens), muzea (ang. Museums), w pomieszczeniu (ang. Indoors), na świeżym powietrzu (ang.outdoor), przyjazne dzieciom (ang. Kids friendly) oraz okoliczne atrakcje (ang. Farther away). Po wybraniu interesującej użytkownika atrakcji użytkownik mógł zobaczyć fotografię, która została wykonana atrakcji,a także miał możliwość przeczytania opisu oraz recenzji użytkowników. Umieszczony był także adres, numer telefonu oraz adres strony internetowej. Aplikacja umożliwiała także nawigację do danej atrakcji. Po naciśnięciu mapy(górny prawy róg) użytkownik mógł zobaczyć lokalizację atrakcji na planie miasta. Daną atrakcję można było zapisać na jednej z domyślnych list: ulubione(ang.favorites), planowane do odwiedzenia (ang. Want to go) oraz ocenione (ang.starred place). Istniała także możliwość stworzenia własnej listy poprzez podanie nazwy.

\par Następny kafelek umożliwiał przejrzenie zapisanych wcześniej atrakcji oraz wyświetlenie ich w wspomnianych wcześniej listach.

\par Aplikacja układała także sugerowane plany dnia (ang. Day plans). Każdy z nich otrzymał własną nazwę. Składał się z mapy,a także ilości oraz odnośników do poszczególnych atrakcji. Aplikacja udzielała użytkownikowi wskazówek odnośnie godzin i dni otwarcia danych atrakcji, ile czasu zazwyczaj spędzają tam zwiedzający, a także jak dużo czasu zajmie przejście do kolejnego punktu z planu.

\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{googletrips3}
\caption{Przeglądanie planu dnia}
\label{fig:GTsubim3}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{googletrips4}
\caption{Przeglądanie informacji na temat regionalnej kuchni}
\label{fig:GTsubim4}
\end{subfigure}
\caption{Google Trips - Travel Planner.}
\label{fig:GTimage2}
\end{figure}

\par Korzystanie z aplikacji umożliwiało użytkownikom otrzymanie zniżek na poszczególne usługi na przykład: taksówki (pre-booked taxis) czy wypożyczenie samochodu (car hire).
Aplikacja posiadała także informacje na temat lokalnej kuchni (kafelek Food \& Drink). Zawierał on krótki opis charakterystycznej dla danego rejonu kuchni, wypunktowane lokalne specjalności kuchni(ang.local specialities), polecane miejsca do jedzenia „na mieście” (ang. Dining out) , a także wskazówki na temat ‘”nocnego życia” (ang. Nightlife). Zakładka „Top Spots” zawierała najbardziej polecane miejsca w poszczególnych kategoriach: ekskluzywne posiłki (ang.high-end dining), budżetowe posiłki (ang. on a budget), miejsca przyjazne rodzinom (ang.family-friendly), śniadania i przekąski (ang. breakfast \& brunch), obiady(ang.lunch),posiłki wegetariańskie (ang.vegetarian-friendly),bary (ang.vodka bars), piwowarnie kraftowe (ang.craft beer) oraz kawiarnie tematyczne(ang.themed cafes). Po wybraniu danej kategorii istniała opcja sortowania propozycji według odległości. Można było także przefiltrować wyniki ze względu na godziny otwarcia (ang. Open now) a także wcześniej zapisanych pozycji (ang. only saved places).
\par Kafelek Zwiedzaj (ang. getting around) umożliwiał sprawdzenie poszczególnych kategorii transportu: on arrival (taxi, ride service, train, bus), public transport (ticket, metro, bus, train, tram), taxi (ang. taxi/ride service), driving, walking \& biking. Każda kategoria była wystarczająco szczegółowo opisana. Zawierała informacje na temat cen, możliwości dojazdu, czasu trwania, możliwych korkach oraz na przykład numerów telefonów do taksówek.
\par Aplikacja zawierała także wskazówki związane z zakupami (ang. Need to know). Informowała użytkownika o najpopularniejszych godzinach otwarcia sklepów, gdzie znajduje się najwięcej sklepów (ang. Shopping districts). Można było tam także znaleźć przykładowe sklepy (ang. Markets) oraz galerie handlowe (ang. Malls).
 
\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{googletrips5}
\caption{Przeglądanie możliwości transportu}
\label{fig:GTsubim5}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{googletrips6}
\caption{Przeglądanie przydatnych informacji}
\label{fig:GTsubim6}
\end{subfigure}
\caption{Google Trips - Travel Planner.}
\label{fig:GTimage3}
\end{figure}

\par Zaplanowana przez użytkownika wycieczka została automatycznie przypisana do konta Google. Istniała możliwość udostępnienia jej znajomym. Można było połączyć kilka wycieczek. Po pobraniu informacji na temat danej wycieczki, istniała możliwość powrotu do planu, gdy telefon jest offline.
\par Niestety aplikacja była dostępna tylko w języku angielskim. Posiadała także kilka innych wad. Podczas wyszukiwania odpowiedniego hotelu aplikacja wyświetla listę miejsc. Przykładowo przy wyszukiwaniu hotelu można było wybrać sklep meblowy. Brakowało także podpowiedzi przy niektórych polach np. cartype. Aplikacja nie zawsze dodawała informacje z serwisu gmail. Nie można było samemu dodać atrakcji za pomocą informacji z Google Maps,a także dodać ręcznie maili z rezerwacjami.

\section{Sygic Travel - Planuj podróż (Anna Malizjusz)}

\par Planowanie podróży umożliwia również aplikacja Sygic Travel: Planuj Podróż, która została pobrana z serwisu Google Play. Jej duża zaleta to możliwość korzystania z większości funkcji w języku polskim oraz brak konieczności tworzenia konta. Jedyną opcją niedostępną dla niezalogowanego użytkownika była synchronizacja z innymi urządzeniami.
\par Podstawowymi informacjami potrzebnymi do rozpoczęcia planowania podróży były cel, data rozpoczęcia oraz data zakończenia (rys.~\ref{fig:STsubim1}). Opcjonalnie można było podać miejsce przybycia oraz zakwaterowania. Wygodny wybór daty umożliwił wyświetlany kalendarz, a miejsca należało wybrać z podanej listy. Istniała również możliwość filtrowania podanych miejsc po nazwie.
\par Po stworzeniu podróży został wyświetlony interfejs oferujący różne opcje (rys.~\ref{fig:STsubim2}). Po wybraniu mapy można zobaczyć mapę miejsca docelowego z zaznaczonymi atrakcjami. Listę atrakcji można też zobaczyć wybierając opcję miejsca. W obu przypadkach można wybrać kategorie, np. zwiedzanie, zakupy, relaks oraz tagi, np. zwierzęta mile widziane (ang. pets allowed), a także możliwe było dodanie miejsca do odwiedzenia w danym dniu. Dodatkowo zaprezentowano szacunkowy czas dotarcia do celu piechotą z miejsca zakwaterowania. Ta część aplikacji nie została przetłumaczona i była dostępna tylko w języku angielskim. Analogicznie można było przeglądać dostępne kwatery po wybraniu opcji hotele. Dostępne były typowe opcje pomocne w poszukiwaniu zakwaterowania, takie jak wybór średniej oceny, przyznanych gwiazdek, typu zakwaterowania czy udogodnień, np. darmowe Wi-Fi (ang. free hotel Wi-Fi) lub klimatyzacja (ang. air conditioning).
\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{sygictravel1}
\caption{Tworzenie nowej podróży.}
\label{fig:STsubim1}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{sygictravel2}
\caption{Menu główne.}
\label{fig:STsubim2}
\end{subfigure}
\caption{Sygic Travel - Planuj podróż.}
\label{fig:STimage}
\end{figure}
\par Innego typu funkcjami aplikacji były wycieczki i aktywności oraz wynajem samochodów. Pierwsza opcja umożliwiała wyszukiwanie wycieczek, a także ich rezerwację oraz płatność. Druga wyszukiwała oferty wynajmu samochodów, wyświetlała wszystkie dostępne informacje oraz umożliwiała rezerwację. W obu funkcjach udostępniono możliwość filtrowania wyników. Poważną wadą wyszukiwarki samochodów do wynajęcia stanowił niejasny komunikat o błędzie w przypadku podania dat z przeszłości, który sugerował sprawdzenie zaznaczonych pól nie wskazując możliwego rozwiązania problemu.
\par Kolejna ciekawa opcja to wycieczka wideo (ang. video tour), która była dostępna tylko dla bardziej popularnych celów podróży. Po wybraniu tej opcji użytkownikowi wyświetlany był film wraz z angielskim komentarzem z jednodniowej wycieczki po wybranym mieście. Prezentowano charakterystyczne i warte odwiedzenia zabytki i atrakcje turystyczne, a użytkownikowi umożliwiono ingerowanie w pokazywany obraz. Filmy oferowały widok 360° po obróceniu telefonu.
\par 3 kolejne funkcje były czysto informacyjne, lecz przydatne. Pokazywały prognozę pogody na najbliższe 14 dni, a także informacje o mieście i okolicy. Obszerność tych danych różniła się w zależności od popularności celu podróży, ale mogła stanowić dobrą podstawę dla nieobeznanych z miejscem użytkowników. Informacje w języku angielskim zostały zaczerpnięte z serwisu Wikivoyage, który można otworzyć w aplikacji oraz przeglądarce internetowej.
\par Po zakupie Sygic Travel Premium za 88,99 zł pojawiały się dodatkowe funkcjonalności, takie jak zapisanie mapy miejsca docelowego do użytku offline. Kolejną opcją było wyświetlenie informacji o zabytkach, hotelach i atrakcjach, których odwiedzenie proponowała aplikacja. Darmowa wersja oferowała wszystkie najbardziej potrzebne opcje, więc zakup rozszerzonej wersji nie był koniecznością, a jedynie nieznacznym zwiększeniem możliwości aplikacji.
\par Aplikacja została zintegrowana z innymi produktami firmy Sygic. Przy każdym miejscu oferowała możliwość nawigacji przy pomocy Sygic GPS Navigation \& Maps, a rezerwacja wycieczek i samochodów była wspierana przez witrynę Sygic Travel, która była dostępna również z komputera z przeglądarki internetowej.
\par Sygic Travel to spełniające podstawowe funkcje narzędzie ułatwiające planowanie podróży. Nie oferowała wielu możliwości, jednak warto zauważyć, że większość z nich była dostępna w wersji podstawowej i nie zmuszała użytkownika do zakupu stosunkowo drogiej wersji premium. Udostępniała bogaty wybór możliwych do odwiedzenia miejsc w wybranym celu podróży, a sam cel mógł należeć do egzotycznych, np. Udaipur w Indiach. Podstawowe informacje, takie jak mapa, atrakcje turystyczne czy prognoza pogody były zawsze dostępne. 

\section{Expedia (Magdalena Solecka)}
\par Kolejna aplikacja do planowania podróży to Expedia, dostępna na urządzeniach z systemem iOS oraz Android. Korzystanie z niej było możliwe po założeniu konta użytkownika. Wśród dostępnych tłumaczeń nie znajdował się język polski. Aplikacja składała się z czterech głównych funkcjonalności: rezerwacja noclegu (ang. Hotels), rezerwacja lotu (ang. Flights), rezerwacja samochodu (ang. Cars) oraz wyszukiwanie ciekawych miejsc w okolicy (ang. Thing to Do). Nie było możliwości wyszukania restauracji w rejonie ani transportu naziemnego, koleją lub autobusem.
\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{expedia1}
\caption{Menu główne.}
\label{fig:Esubim1}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\linewidth, width=5cm]{expedia2}
\caption{Wyszukiwanie noclegu.}
\label{fig:Esubim2}
\end{subfigure}
\caption{Expedia.}
\label{fig:Eimage}
\end{figure}
\par W celu wyszukania noclegu należało podać następujące dane: datę zameldowania i wymeldowania, miasto docelowe podróży, liczbę pokoi oraz osób do zakwaterowania. Zaprezentowane przez aplikację wyniki mogły zostać posortowane po cenie lub recenzjach użytkowników, a także przefiltrowane względem darmowego anulowania rezerwacji, śniadaniu wliczonym w cenę pobytu, klimatyzacją czy Wi-Fi. Wygodnym rozwiązaniem była mapka z naniesionymi na nią punktami z ceną w miejscu, w którym znajdował się oferowany pokój, co umożliwiało łatwiejszą ocenę odległości od centrum.
\par W przypadku rezerwacji miejsca w samolocie można było wyszukać lot w jedną lub obie strony. Należało podać miejsce wylotu i przylotu oraz daty. Przedstawione wyniki można było porządkować według rosnącego kosztu. Aplikacja nie dawała możliwości porównania cen w różnych dniach np. w formie kalendarza uzupełnionego najniższymi cenami w danym dniu, co przy podróżowaniu z niskim budżetem byłoby pomocne. Możliwe było równoczesne wyszukanie lotów oraz noclegu (ang. Bundle Deals).
\par Aplikacja oferowała również możliwość wypożyczenia samochodu. Tak jak w poprzednich dwóch przypadkach należało podać przedział czasu korzystania z pojazdu, miejsce odbioru i pozostawienia. Wyświetlone informacje o pojazdach były przydatne przy dokonywaniu wyboru, automatyczna czy manualna skrzynia biegów, ilość pasażerów.Dostępne sortowanie po cenie.
\par Ostatnia funkcjonalność, wyszukiwanie atrakcji, zabytków, ciekawych wydarzeń. Wymagane ramy czasowe oraz lokalizacja. Rezultaty mogły być przeglądane po cenie lub popularności. Nie umożliwiono użytkownikowi oceny odległości między zaproponowanymi miejscami tak jak w przypadku noclegu, ale pomocny był przybliżony czas, który należy przeznaczyć na każdą z atrakcji.
\par Wszystkie rezerwacje wykonane za pomocą aplikacji Expedia, można było przeglądać w zakładce Wycieczki (ang. Trips) i takim zestawem dzielić się ze współtowarzyszami podróży również korzystających z aplikacji.

\chapter{Specyfikacja wymagań systemowych - ekstrakt (Anna Malizjusz)}
\par W celu lepszego zrozumienia wymagań projektu inżynierskiego przygotowano dokument SWS (Specyfikacji Wymagań Systemowych) w całości umieszczony na załączonej do pracy płycie~CD. Dokonano identyfikacji udziałowców projektu i otoczenia systemu z uwzględnieniem użytkowników oraz systemów zewnętrznych. Wyróżniono cele projektu oraz wymagania, których spełnienie będzie kluczowe dla końcowej akceptacji systemu. Poniżej przedstawiono najistotniejsze elementy SWS, które miały największy wpływ na projekt i~implementacje systemu.
\newline
\newline
\noindent Wyróżniono udziałowców, których wpływ na system powinien być największy:

\begin{itemize}
\item programiści,
\item promotor,
\item użytkownik.
\end{itemize}

\noindent A także dokumenty, które należało uwzględnić w pracy:

\begin{itemize}
\item regulamin aplikacji,
\item rozporządzenie o ochronie danych osobowych (RODO).
\end{itemize}

\par Docelowego użytkownika zidentyfikowano jako młodego człowieka, najczęściej studenta o ograniczonym budżecie i czasie, który może poświęcić na planowanie podróży. Posiada on smartfona z dostępem do internetu oraz używa systemu operacyjnego Android. Chce podróżować i kontaktować się z przyjaciółmi poprzez aplikację. Często zapomina o terminach i~koniecznych dokumentach, więc potrzebuje przypomnień oraz dostępu do skanów przy pomocy telefonu.

\par Wyróżniono systemy zewnętrzne, z którymi zintegrowano aplikację. Skupiono się na dostępie do zewnętrznego API udostępnionego przez serwis Here \cite{Here}, które umożliwiało dostęp do map, nawigacji i wyszukiwania obiektów takich jak hotele, restauracje, zabytki, itp. Zaletą serwisu był darmowy dostęp do danych. Here umożliwiało wykonanie 250 tys. zapytań miesięcznie bez dodatkowych opłat, a każdy kolejny tysiąc kosztował 1\$, co zostało uznane za wystarczające dla testowania aplikacji. Uwzględniono również system GPS, który był niezbędny do zrealizowania podstawowych funkcjonalności, np.~wyszukiwania obiektów w pobliżu aktualnej lokalizacji. W tym celu zdecydowano skorzystać z możliwości oferowanych przez serwis Google Play w paczce \textit{com.google.android.gms.location}\cite{gms.location}.

\par
\noindent \newline Określono najważniejsze cele projektu:

\begin{itemize}
\item zwiększenie zadowolenia z podróży,
\item zaspokajanie potrzeb informacyjnych użytkowników,
\item zoptymalizowanie trasy,
\item zmniejszenie ilości spóźnień,
\item ułatwienie komunikacji pomiędzy użytkownikami,
\item ułatwienie możliwości koordynacji planu dnia przez użytkownika,
\item skrócenie czasu oczekiwania na dany środek transportu,
\item zmniejszenie czasu przeznaczonego na planowanie podróży,
\item zmniejszenie poziomu stresu użytkowników podczas planowania podróży.
\end{itemize}

\par
\noindent\newline Zidentyfikowano wymagania funkcjonalne, które jednocześnie stanowiły kryteria akceptacyjne projektu: 

\begin{itemize}
\item rejestracja i logowanie użytkownika,
\item dodanie, przeglądanie i edycja planu podróży i planu dnia,
\item wyszukanie elementu w pobliżu danej lokalizacji,
\item wygenerowanie planu dnia/podróży,
\item wyszukanie i zaproszenie innego użytkownika do wyświetlania lub edycji podróży,
\item dodanie oceny do planu dnia, podróży lub odwiedzonego miejsca,
\item otrzymanie propozycji na podstawie ocen,
\item wyszukanie transportu między lokalizacjami,
\item wyszukanie najkrótszej trasy,
\item skanowanie biletów i innych dokumentów potrzebnych w trakcie podróży,
\item zapisywanie podróży i dokumentów na urządzeniu, aby możliwe było korzystanie z nich bez dostępu do internetu.
\end{itemize}

\par
\noindent Wyróźniono dodatkowe wymagania, które nie były niezbędne do realizacji projektu, ale znacznie zwiększały możliwości aplikacji: 

\begin{itemize}
\item wyszukanie zakwaterowania,
\item powiadomienie o obiekcie w okolicy,
\item powiadomienie o opóźnieniu,
\item oznaczenie elementu z planu dnia jako wykonany,
\item powiadomienia dotyczące lotów,
\item przeglądanie statystyk zrealizowanych podróży,
\item udostępnianie zrealizowanego punktu planu dnia w mediach społecznościowych.
\end{itemize}

\par Dodatkowo zostały określone wymagania jakościowe dotyczące aplikacji. Ze względu na RODO przetwarzanie danych użytkowników ograniczono do minimum i~zdecydowano o wyświetlaniu użytkownikom informacji o sposobie używania danych. Postanowiono skorzystać z bezpiecznych algorytmów szyfrowania i uwierzytelniania, aby zapewnić danym bezpieczeństwo. 
Zobowiązano się do zapewnienia autentyczności proponowanych podróży, tj. sugerowany czas spędzony w danym obiekcie jest zbliżony do rzeczywistego i trafności polecanych obiektów. Zapytania użytkowników mają być obsługiwane nie dłużej niż 5~s., a układanie planu dnia będzie trwać maksymalnie 10~s.

\par Za docelowe urządzenie przyjęto smartfon z systemem operacyjnym Android, którego minimalna wersja to 5.0 (Lollipop), co miało zapewnić obsługę ponad 94\% urządzeń z systemem Android (dane aktualne na dzień 05.05.2019\cite{Android usage}). Spodziewane wymiary urządzeń to od~115.20~mm~x~58.60~mm do~242,8~mm~x~189,7~mm. Zaplanowano rozszerzenie działania aplikacji na telefony z systemem operacyjnym iOS.

\par Zwrócono uwagę na zagwarantowanie czytelności interfejsu użytkownika. Zaplanowano użycie stonowanych, niejaskrawych kolorów i ograniczenie dostępnych informacji na jednym ekranie z możliwością przejścia do kolejnych stron lub filtrowania wyników. Dostępne ma być powiększenie ekranu.

\chapter{Projekt systemu (Magdalena Solecka)}
\par System postanowiono podzielić na następujące komponenty:
\begin{itemize}
\item Po stronie serwera:
\begin{itemize}
\item Podsystem planowania (ang. Planning subsystem)
\item Podsystem wyszukiwania (ang. Search subsystem)
\item Podsystem zarządzania danymi użytkownika (ang. User Data Management Subsystem)
\item Podsystem polecający (ang. Recommendation Subsystem)
\item Podsystem usług społecznościowych (ang. Social Services Subsystem)
\item Podsystem zarządzania (ang. Management Subsystem)
\end{itemize}
\item Po stronie aplikacji mobilnej:
\begin{itemize}
\item GUI
\item Prezenter (ang. Presenter)
\item Podsystem zarządzania plikami (ang. File Management Subsystem)
\item Podsystem skanowania (ang. Scanning Subsystem)
\end{itemize}
\end{itemize}
\par Kontakt klienta mobilnego z aplikacją serwerową zaplanowano poprzez interfejs komunikacji (ang. communication interface). Zależności pomiędzy podsystemami zostały przedstawione na diagramie (rys.~\ref{fig:subsystems}).

\indent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{subsystems}
\caption{Diagram komponentow systemu.}
\label{fig:subsystems}
\end{figure}

\section{Scenariusze użycia}
\par Zaprojektowano scenariusze użycia w celu dokładnego określenia sposobów, w które użytkownicy będą korzystać z aplikacji. Wyróżniono najważniejsze:
\begin{enumerate}
  \item Stworzenie planu dnia.
  \item Wygenerowanie planu dnia.
  \item Stworzenie planu podróży.
  \item Interakcje z innymi użytkownikami aplikacji.
  \item Interakcje serwera z aplikacją w czasie trwania podróży.
\end{enumerate}

\subsection{Stworzenie planu dnia (Magdalena Solecka)}
\par Martyna widzi pusty ekran planu dnia. Wpisuje miasto docelowe wyjazdu - Paryż. Wybiera przycisk "+" i wybiera atrakcje. Ukazuje się przed ną ekran wyszukiwania ze znakiem wyszukiwania,a po chwili z wynikami wyszukiwania w formie listy atrakcji. Wybiera jeden z elementów listy – katedra Notre Dame i czyta jej opis. Wybiera przycisk "Dodaj". Widzi ponownie ekran planu Dnia z dodaną przez siebie atrakcją. Wybiera w ten sposób kilka kolejnych atrakcji. Ponownie wybiera przycisk "+" i wybiera restauracje. Ponownie widzi ekran wyszukiwania z listą restauracji. Wybiera pasujący jej obiekt i przy użyciu przycisku "Dodaj" zostaje on dodany do  planu dnia który ponownie wyświetla się przed nią. Użytkownik wybiera przycisk "Ułóż" i czeka aż aplikacja zakończy obliczanie najbardziej optymalnej trasy. Po kilku sekundach plan dnia jest już gotowy. Martyna stwierdza jednak że potrzebuje w ciągu dnia odpoczynku dlatego postanawia przesunąć zwiedzanie katedry Notre Dame na następny dzień. Wybiera element z katedrą i przycisk "Przenieś", a następnie numer dnia podróży. Następnie stwierdza, że właściwie nie interesuje jej sztuka sakralna, więc usuwa element z planu przesuwając go w prawo.

\noindent\newline Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Użytkownik wybrał opcję stwórz plan dnia.
\end{enumerate}

\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Użytkownik stworzył plan dnia.
\end{enumerate}

\subsection{Wygenerowanie planu dnia (Anna Malizjusz)}
\par Martyna stworzyła wyjazd, lecz nie ma pomysłu na spędzenie dnia. Wybiera w aplikacji swoją podróż, po czym generuje przyciskiem plan dnia. Zostaje wyświetlony rezultat, który może dowolnie modyfikować. (rys.~\ref{fig:generateDayPlan}).

\noindent Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Użytkownik wybrał podróż.
\end{enumerate}
\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Wyświetlono proponowany plan podróży.
\end{enumerate}

\noindent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{generateDayPlan}
\caption{Generowanie planu dnia.}
\label{fig:generateDayPlan}
\end{figure}
\FloatBarrier


\subsection{Stworzenie planu podróży (Karolina Makuch)}
\FloatBarrier
\par Martyna pragnie zaplanować podróż za pomocą aplikacji poprzez aplikację podróż.  (rys.~\ref{fig:addTravel}).

\noindent\newline Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Użytkownik wybrał opcję stwórz plan podróży.
\end{enumerate}
\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Użytkownik stworzył plan podróży.
\end{enumerate}

\noindent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{addTravel}
\caption{Tworzenie planu podróży.}
\label{fig:addTravel}
\end{figure}

\FloatBarrier
\subsection{Interakcje z innymi użytkownikami aplikacji (Anna Malizjusz)}
\par Martyna wyjeżdża na wakacje razem z~koleżanką, więc chce udostępnić jej swój plan podróży. Zaprasza nowego użytkownika do skorzystania z aplikacji (rys.~\ref{fig:inviteFriend}), po czym dodaje znajomego (rys.~\ref{fig:addFriend}) i~zaprasza koleżankę do edytowania podróży (rys.~\ref{fig:shareTravel}).
\FloatBarrier
\subsubsection{Zapraszanie użytkownika do aplikacji}

\noindent Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Użytkownik wybrał z menu opcję "Znajomi".
\end{enumerate}
\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Wiadomość e-mail została wysłana lub napotkano błąd.
  \item Użytkownik otrzymał informację o pomyślnym wysłaniu zaproszenia lub błędzie.
\end{enumerate}

\noindent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{inviteFriend}
\caption{Zapraszanie użytkownika do skorzystania z aplikacji.}
\label{fig:inviteFriend}
\end{figure}
\FloatBarrier
\subsubsection{Dodawanie znajomego}

\noindent Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Użytkownik wybrał z menu opcję "Znajomi".
\end{enumerate}
\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Użytkownik otrzymał informację o rezultacie.
  \item Drugi użytkownik otrzymał informację zaproszenie.
\end{enumerate}

\noindent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{addFriend}
\caption{Dodanie użytkownika do znajomych.}
\label{fig:addFriend}
\end{figure}
\FloatBarrier
\subsubsection{Udostępnienie podróży}

\noindent Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Użytkownik wybrał podróż do udostępnienia.
  \item Użytkownik docelowy jest znajomym użytkownika udostępniającego.
\end{enumerate}
\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Użytkownik otrzymał informację o rezultacie.
  \item Drugi użytkownik otrzymał informację o udostępnionej podróży.
\end{enumerate}

\noindent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{shareTravel}
\caption{Udostępnienie podróży.}
\label{fig:shareTravel}
\end{figure}

\subsection{Interakcje serwera z aplikacją w czasie trwania podróży (Dorota Tomczak)}
\par Martyna wraz z koleżanką odbywają zaplanowaną poprzez aplikację podróż. W drodze do jednej z atrakcji aplikacja powiadamia Martynę o interesującym obiekcie znajdującym się niedaleko miejsca, w którym przebywają. Dziewczyny ruszają do wskazanej lokalizacji. Tracą poczucie czasu, więc aplikacja informuje je, że jeśli się nie pośpieszą, nie zdążą dojść do następnego punktu planu dnia przed jego zamknięciem (rys.~\ref{fig:whileTravelling}).

\noindent\newline Warunki początkowe:
\begin{enumerate}
  \item Użytkownik jest zalogowany.
  \item Aplikacja ma dostęp do internetu.
  \item Aplikacja ma dostęp do lokalizacji użytkownika.
  \item Użytkownik nie zablokował powiadomień od aplikacji.
  \item Użytkownik utworzył plan podróży i jest w określonym miejscu i czasie.
\end{enumerate}
\par
\noindent\newline
Warunki końcowe:
\begin{enumerate}
  \item Użytkownik otrzymał odpowiednie powiadomienie.
\end{enumerate}

\noindent\newline
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{whileTravelling}
\caption{Otrzymywanie powiadomień podczas trwania podróży.}
\label{fig:whileTravelling}
\end{figure}


\chapter{Aplikacja mobilna}

\section{Projekt i implementacja oparte na wzorcu MVP (Dorota Tomczak)}
\par Pracę nad aplikacją mobilną rozpoczęto od stworzenia bazowego projektu składającego się na kilka pustych widoków, do których to następnie można było dodawać kolejne funkcjonalności. W celu zachowania najlepszych praktyk programistycznych zdecydowano się na oparciu projektu o wzorzec architektoniczny MVP (ang. model-view-presenter). Jest to wzorzec szczególnie nadający się do implementacji w aplikacjach mobilnych na systemy Android ze względu na aktywności (ang. activity), które pełnią funkcję środkowej warstwy – widoku (ang. view). W implementacji wzorca w tym projekcie widok jest pasywny (ang. passive view) tzn. widok powinien odpowiadać jedynie za wyświetlanie interfejsu i użycie bibliotek związanych z Androidem. Cała logika aplikacji ma być zawarta w prezenterze (ang. presenter), który pełni funkcję kontrolera.

\par Zastosowanie wzorca MVP pozwoliło na zachowanie porządku w strukturze projektu i przejrzysty podział na warstwy. Do każdej aktywności, czyli nowego ekranu w aplikacji, utworzono interfejs zwany kontraktem (ang. contract) zawierający opis interakcji jakie mogą zajść pomiędzy prezenterem a widokiem, a w szczególnych przypadkach również między prezenterem a adapterem, który odpowiada za wyświetlanie listy obiektów. Klasy aktywności i prezentera implementują interfejsy zawarte w kontrakcie, prezenter jest wstrzykiwany do widoku a referencja widoku jest przekazywana do prezentera w konstruktorze.

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{launcherContract}
\caption{Prosty kontrakt widoku odpowiadający za przekierowanie do widoku logowania lub listy podróży.}
\label{fig:launcherContract}
\end{figure}

\par Do wstrzykiwania zależności, w tym prezenterów do aktywności, wykorzystano popularny framework \textit{Dagger 2}\cite{Dagger 2}, co ostatecznie okazało się być nie najlepszym wyborem – należało dodać dwie dodatkowe klasy do każdej aktywności, co przy dużej ich liczbie wygenerowało wiele plików o bardzo podobnej strukturze. Ponadto niemalże jedynymi wstrzykiwanymi obiektami były obiekty klas prezenterów. 

\section{Komunikacja z aplikacją serwerową (Anna Malizjusz)}
\par Aplikacja mobilna musi komunikować się z RESTowym API udostępnianym przez serwer. W tym celu wykorzystano klienta o nazwie Retrofit 2 \cite{Retrofit library}. Dzięki niemu w łatwy sposób można zaimplementować interfejs odpowiedzialny za wysyłanie zapytań i odbieranie odpowiedzi.

\par Napisano kilka klas, aby umożliwić prostą komunikację w aplikacji. Interfejs \textit{ServerApi} zawierał zbiór metod z odpowiednimi adnotacjami @PUT, @POST, @GET, @DELETE i nazwami punktów końcowych. Metody nie wymagały implementacji przez programistów, ponieważ należało to do odpowiedzialności klienta Retrofit 2.

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{serverApi}
\caption{Przykładowa zawartość interfejsu używanego przez Retrofit 2.}
\label{fig:tokenPayload}
\end{figure}

\par Dodatkowo zaimplementowano klasę pomocniczą konfigurującą klienta. Udostępniała ona zmienną (ang. property), która była przygotowanym interfejsem do komunikacji. Ustawiono w niej adres serwera REST, a także konwertery przeprowadzające serializację obiektów do formatu JSON oraz deserializację z otrzymanego ciągu znaków w formacie JSON do obiektu będącego instancją danej klasy. Skorzystano z klasy \textit{GsonConverter}, która jest oferowana przez Retrofit API. Wykorzystano wzorzec projektowy interceptor implementując klasę \textit{AuthTokenInterceptor}, którego rolą było dodanie do każdego zapytania nagłówka (ang. header) z lokalnie zapisanym tokenem identyfikującym użytkownika. Interceptor aplikacji jest wywoływany zawsze i tylko jeden raz, nie wpływają na to przekierowania ani ponawianie zapytań. Aby zintegrować interfejs używanego klienta z interceptorem, należało dodać dodatkowego klienta - \textit{OkHttpClient}\cite{OkHttpClient}. Pochodzi z biblioteki OkHTTP, którą można było wykorzystać do komunikacji aplikacji mobilnej z serwerem, jednak postawiono wybrać Retrofit 2 z uwagi na mniejszy poziom skomplikowania oferowanego API.

\par Rezultatem każdego zapytania jest struktura \textit{Single<Response<T> >}, gdzie T jest oczekiwanym typem zwracanego obiektu. Obiekt \textit{Single} informuje o tym, że jest spodziewana pojedyncza odpowiedź. \textit{Response} jest strukturą zdefiniowaną w projekcie inżynierskim. Zawiera kod odpowiedzi opisywany szerzej przy sposobie implementacji błędów, a także także pole \textit{data} z przesłanymi przez serwer danymi.

\section{Wyszukiwanie atrakcji turystycznych i zakwaterowania (Anna Malizjusz)}

\chapter{Serwer REST}
\section{Implementacja serwera (Anna Malizjusz)}
\par Serwer dla aplikacji mobilnej został zaimplementowany w języku Kotlin. Celem było stworzenie bezstanowego API zgodnego z tzw. RESTful Web Service. Oznacza to, że na serwerze nie jest utrzymywana sesja użykownika, a każde zapytanie jest niezależne od poprzednich. Każdorazowo należy podać wszystkie niezbędne informacje niezbędne do realizacji żądania, m. in. token, który potwierdza tożsamość użytkownika i uprawnia go do określonych akcji.
\par Wykorzystano framework Spring Boot\cite{Spring documentation}. Jest on oparty na platformie Spring, która dostarcza mechanizmów wstrzykiwania zależności, możliwości użycia wzorca MVC (ang. model-view-controller), a także modułów do implementacji testów jednostkowych. Celem obu frameworków jest ułatwienie implementacji serwera. Jedną z zalet użytego niniejszej pracy frameworka jest prosta konfiguracja, która nie wymaga tworzenia plików w formacie xml. Wynika to z zastosowania reguły \textit{konwencja ponad konfigurację} (ang. convention over configuration). Programista nie musi definiować wszystkich ustawień, jeśli stosuje się do przyjętych konwencji. W przypadku technologii Spring Boot kluczowe są adnotacje nad klasami pełniącymi określone role. 
Konfiguracja serwera zachodzi automatycznie na podstawie zależności, jeśli dodano adnotację "@EnableAutoConfiguration" do klasy uruchamiającej serwer. Framework dostarcza również narzędzi do tworzenia punktów końcowych (ang. endpoints).

\par Skorzystano z mechanizmu wstrzykiwania zależności. Klasy mogą być oznaczone jako komponenty (@Component), serwisy (@Service). Serwis jest szczególnym typem komponentu. Komponenty są zarządzalnymi obiektami w aplikacji oraz mogą być wstrzykiwane do pól odpowiedniego typu, które są oznaczone adnotacją @Autowired. Serwisy to elementy, które należą do logiki biznesowej.
 
\par Definicję punktów końcowych umieszczono w klasach kontrolerów oznaczonych adnotacją "@RestController". Zdefiniowano kilka rodzajów kontrolerów, aby rozdzielić odpowiedzialność za poszczególne zadania:
\begin{itemize}
\item kontroler użytkowników jako \textit{ServerUserController}
\item kontroler podróży jako \textit{ServerTravelController}
\item kontroler odpowiedzialny za skany jako \textit{ServerScanController}
\item kontroler pośredniczący w komunikacji z zewnętrznym API dostarczanym przez firmy Google oraz Here: \textit{ServerHereGoogleApiController}
\item kontroler funkcji rekomendujących: \textit{ServerRecommendationController}
\end{itemize}

\par W każdym z kontrolerów wyróżniono punkty końcowe (ang. endpoints). Zastosowano powszechną konwencję nazewnictwa oraz znaczenie czasowników protokołu HTTP. Przykładowo dodawanie (POST), usuwanie (DELETE), aktualizacja (PUT) oraz odczytanie (GET) podróży obsługiwane w kontrolerze \textit{ServerTravelController} odbywa się w następujący sposób:
\begin{itemize}
\item \textit{@GetMapping("users/{userId}/travels")} zwraca podróże należące do użytkownika o podanym numerze ID;
\item \textit{@PostMapping("users/{userId}/travels")} dodaje podróż podaną w ciele zapytania (ang. body) do podróży użytkownika o podanym numerze ID;
\item \textit{@PutMapping("users/{userId}/travels")} aktualizuje podróże zawarte w ciele zapytania (ang. body);
\item \textit{@DeleteMapping("users/{userId}/travels")} umożliwia usunięcie listy podróży, która została wysłana w ciele zapytania.
\end{itemize}

\par Każde zapytanie powinno zawierać w nagłówku token użytkownika, który jest sprawdzany w celu weryfikacji źródła zapytania. Parametry ścieżki (ang. path parameters) punktów końcowych uszczegóławiają zasób, np. "userId" w powyższym przykładzie. Dodatkowe parametry zapytania (ang. query parameters) i ciało zapytania(ang. body)  pozwala na sprecyzowanie żądania.

\section{Obsługa sytuacji wyjątkowych (Dorota Tomczak)}
\par Aplikacja mobilna komunikuje się z serwerem poprzez REST'owe API, jeśli więc po stronie serwera dojdzie do sytuacji wyjątkowej, aplikacja powinna otrzymać wiadomość o tym, co poszło nie tak i odpowiednio ją obsłużyć. W tym celu zdefiniowano kilkanaście własnych wyjątków, czyli klas dziedziczących po klasie java.lang.Exception oraz implementujących własny interfejs ApiException, który zawiera kod błędu wraz z wiadomością opisującą błąd. W celu uniknięcia tworzenia wielu bloków try-catch oraz powielania bloków kodu zaimplementowano globalny moduł obsługi wyjątków, czyli klasę opatrzoną adnotacją \textit{@RestControllerAdvice}, zawierającą dwie metody z adnotacjami \textit{@ExceptionHandler} – jedna służąca do obsługi nowo zdefiniowanych wyjątków, a druga do pozostałych. W obu tych metodach złapany wyjątek jest dodawany do logów serwera, a następnie zwracana jest odpowiedź z odpowiednim kodem błędu. Tak zdefiniowany moduł pozwala na obsługę wszystkich wyjątków występujących na serwerze po dowolnym żądaniu obsłużonym przez każdy z kontrolerów.

\section{Uwierzytelnienie i autoryzacja użytkownika (Anna Malizjusz)}
\par Podstawowy mechanizm uwierzytelnienia i autoryzacji opiera się na standardzie opisanym po raz pierwszy w 2010 roku jako JSON Web Token. Jest on "kompaktowym i bezpiecznym sposobem przesyłania informacji między dwiema stronami" (RFC 7519\cite{JWT}). Użyto biblioteki \textit{io.jsonwebtoken.jjwt}\cite{JWT library}, która dostarcza interfejs do generowania i odczytywania tokenów w przystępny sposób.

\par Uwierzytelnienie użytkownika odbywa się podczas logowania. Serwer porównuje podany adres email oraz zmodyfikowane funkcją mieszającą hasło z danymi zapisanymi w bazie danych. Jeżeli informacje są zgodne, na ich podstawie jest generowany token. JWT pozwala na dodanie twierdzeń (ang. claims) i ustawienie czasu ważności, które zostaną zaszyfrowane przy pomocy algorytmu HS256 i sekretnego klucza. Używane są następujące twierdzenia określające podane cechy tokenu:
\begin{itemize}
\item \textit{iss} - wydawca tokenu (ang. issuer),
\item \textit{sub} - podmiot (ang. subject),
\item \textit{email} - adres email użytkownika,
\item \textit{id} - id użytkownika,
\item \textit{generatedTimestamp} - czas wygenerowania tokenu.
\end{itemize}
\par Przykładowy token zapisany składający się z 3 części XXX.YYY.ZZZ zaprezentowano poniżej:\\eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJBY2Nlc3NUb2tlbiIsImdlbmVyYXRlZFRpbWVzdGFtcCI6eyJ5Z\\WFyIjoyMDE5LCJtb250aCI6Ik5PVkVNQkVSIiwibW9udGhWYWx1ZSI6MTEsImRheU9mTW9udG\\
giOjE3LCJjaHJvbm9sb2d5Ijp7ImlkIjoiSVNPIiwiY2FsZW5kYXJUeXBlIjoiaXNvODYwMSJ9LCJkYXl\\
PZldlZWsiOiJTVU5EQVkiLCJsZWFwWWVhciI6ZmFsc2UsImRheU9mWWVhciI6MzIxLCJlcmEiOi\\
JDRSJ9LCJpc3MiOiJUcmF2ZWxBcHBfU2VydmVyIiwiaWQiOjEwLCJleHAiOjE1NzQxMDc4NTksI\\mVtYWlsIjoicXFxMSJ9.vs9PVbgkzxsLpRqxXY0Jaey6fmMXdOLwQW\_dUe9Xxcw

\par Pierwsza część to zakodowany nagłówek, który zawiera algorytm szyfrujący oraz typ tokenu. 
Kolejna jest zawartość, którą tworzą określone przy generacji tokenu twierdzenia. Ostatnia część to podpis. Użyto w nim znanego tylko serwerowi sekretnego klucza, niezbędnego do odszyfrowania otrzymanego od klienta tokenu.
\par Użytkownik aplikacji mobilnej przechowuje swój token i każdorazowo dołącza go do wysyłanych zapytań. Aplikacja serwerowa przy użyciu klucza odczytuje go i weryfikuje otrzymane dane, w szczególności datę ważności tokenu oraz id użytkownika.

\par Rozszyfrowany token jest zapisywany w formacie JSON w postaci, która jest czytelna i zrozumiała dla człowieka. Dzięki użytej bibliotece \textit{io.jsonwebtoken.jjwt} z tokenu w formacie JSON można odczytywać dane jak ze słownika, np.
\textit{Jwts.parser().setSigningKey(SECRET\_KEY).parseClaimsJws(token).body["id"].toString()}, aby odczytać wartość twierdzenia o nazwie "id".

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{tokenPayload}
\caption{Rozszyfrowana zawartość podanego powyżej tokenu.}
\label{fig:tokenPayload}
\end{figure}


\section{Komunikacja z zewnętrznym API (Anna Malizjusz)}

\chapter{Placeholder - baza danych}

\chapter{Placeholder - testy}

\chapter{Placeholder - Podręcznik użytkownika}

\chapter{Podsumowanie}
\bibliographystyle{plain}
\begin{thebibliography}{1}
\addcontentsline{toc}{chapter}{Bibliografia}
  \bibitem{Here} developer.here.com
  \bibitem{gms.location} developers.google.com/android/reference/com/google/android/gms/location/package-summary
  \bibitem{Android usage} gs.statcounter.com/android-version-market-share/mobile-tablet/worldwide
  \bibitem{Spring documentation} https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/
  \bibitem{JWT} https://tools.ietf.org/html/rfc7519
  \bibitem{JWT library} https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt
  \bibitem{Retrofit library} https://square.github.io/retrofit/
  \bibitem{OkHttpClient} https://square.github.io/okhttp/
  \bibitem{Dagger 2} https://github.com/google/dagger
\end{thebibliography}


\listoffigures
\listoftables

\end{document}
